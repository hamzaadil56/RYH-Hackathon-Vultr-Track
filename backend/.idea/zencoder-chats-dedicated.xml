<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ai.zencoder.plugin.chat.state-dedicated">
    <option name="activeChatId" value="8452b180-1202-43c1-88c7-cd0d3f5a2a5f" />
    <option name="chatSessions" value="{&quot;b89155b3-c4d9-4739-b8c4-f8152c1fd110&quot;:{&quot;id&quot;:&quot;b89155b3-c4d9-4739-b8c4-f8152c1fd110&quot;,&quot;createdAt&quot;:1751745339274,&quot;updatedAt&quot;:1751745347343,&quot;title&quot;:&quot;see why im geeting errors in main&quot;,&quot;messages&quot;:[{&quot;id&quot;:&quot;673d0d79-e95a-46e9-9581-ab6f1d7cd980&quot;,&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;see why im geeting errors in main&quot;}],&quot;context&quot;:{&quot;codebaseEnabled&quot;:true,&quot;ragFiles&quot;:[{&quot;path&quot;:&quot;/core/config.py&quot;,&quot;fsPath&quot;:&quot;C:\\core\\config.py&quot;,&quot;sources&quot;:[&quot;keyword_search&quot;]},{&quot;path&quot;:&quot;agents\\job_creator_agent.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\agents\\job_creator_agent.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;__init__.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\__init__.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\database.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\database.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;schemas\\auth.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\schemas\\auth.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;main.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;.gitignore&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.gitignore&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;README.md&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\README.md&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;pyproject.toml&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\pyproject.toml&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;alembic\\alembic.ini&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\alembic\\alembic.ini&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\config.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\config.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\security.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\security.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;README.md&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\README.md&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;api/routes/auth.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\api\\routes\\auth.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;core/config.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\config.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;core/database.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\database.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;services/auth_service.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\services\\auth_service.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;main.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;__init__.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\__init__.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;models/models.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\models\\models.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;.env&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.env&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;core/security.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\security.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]}],&quot;rerankedFiles&quot;:[{&quot;path&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;}],&quot;usedFilePaths&quot;:[{&quot;path&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;}]},&quot;createdAt&quot;:1751745339276,&quot;isInternal&quot;:false},{&quot;id&quot;:&quot;cdaa60ba-6768-4a41-a912-eb16f838671d&quot;,&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;To help you identify why you're getting errors in your `main.py` file, let's go through the code snippet you've provided. Here are some potential areas to check for errors:\n\n1. **Imports**: Ensure that all the modules and packages you are importing (`fastapi`, `CORSMiddleware`, `engine`, `Base`, `auth_router`, `settings`) are correctly installed and accessible. You can verify this by checking your `requirements.txt` or using `pip list`.\n\n2. **Database Connection**: The line `Base.metadata.create_all(bind=engine)` suggests that you are setting up database tables. Ensure that your `engine` is correctly configured to connect to your database. Check your database connection string and credentials.\n\n3. **CORS Configuration**: The CORS middleware is set to allow all origins. While this is fine for development, ensure that this is intentional and not causing issues in your environment.\n\n4. **Router Inclusion**: The line `app.include_router(auth_router)` includes routes from `auth_router`. Make sure that `auth_router` is correctly defined and imported from `api.routes.auth`.\n\n5. **Settings**: The `reload=settings.debug` in the `uvicorn.run` call suggests that you are using a settings module. Ensure that `settings` is correctly imported and that it contains a `debug` attribute.\n\n6. **Running the Application**: When running the application with `uvicorn`, ensure that you are in the correct directory and that the `main.py` file is accessible.\n\nIf you are encountering specific error messages, please provide them so I can give more targeted advice. Additionally, ensure that your environment is set up correctly and that all dependencies are installed.&quot;}],&quot;context&quot;:{&quot;codebaseEnabled&quot;:true,&quot;ragFiles&quot;:[{&quot;path&quot;:&quot;/core/config.py&quot;,&quot;fsPath&quot;:&quot;C:\\core\\config.py&quot;,&quot;sources&quot;:[&quot;keyword_search&quot;]},{&quot;path&quot;:&quot;agents\\job_creator_agent.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\agents\\job_creator_agent.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;__init__.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\__init__.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\database.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\database.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;schemas\\auth.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\schemas\\auth.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;main.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;.gitignore&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.gitignore&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;README.md&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\README.md&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;pyproject.toml&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\pyproject.toml&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;alembic\\alembic.ini&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\alembic\\alembic.ini&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\config.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\config.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\security.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\security.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;README.md&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\README.md&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;api/routes/auth.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\api\\routes\\auth.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;core/config.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\config.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;core/database.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\database.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;services/auth_service.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\services\\auth_service.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;main.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;__init__.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\__init__.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;models/models.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\models\\models.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;.env&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.env&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;core/security.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\security.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]}],&quot;rerankedFiles&quot;:[{&quot;path&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;}],&quot;usedFilePaths&quot;:[{&quot;path&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;}]},&quot;createdAt&quot;:1751745347343,&quot;isInternal&quot;:false}],&quot;isAgent&quot;:false},&quot;8452b180-1202-43c1-88c7-cd0d3f5a2a5f&quot;:{&quot;id&quot;:&quot;8452b180-1202-43c1-88c7-cd0d3f5a2a5f&quot;,&quot;createdAt&quot;:1751746538886,&quot;updatedAt&quot;:1751746607803,&quot;title&quot;:&quot;Python Deprecation and Import Errors&quot;,&quot;messages&quot;:[{&quot;id&quot;:&quot;4526884b-d701-4c63-891d-f38c8574baba&quot;,&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;why this errors:&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py:7: DeprecationWarning: The 'warn' method is deprecated, use 'warning' instead&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;  logger.warn('cjson not found, falling back to stdlib json')&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;cjson not found, falling back to stdlib json&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Traceback (most recent call last):&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;  File \&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py\&quot;, line 19, in &lt;module&gt;&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;    from Crypto.Hash import HMAC, SHA256, SHA384, SHA512&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;ModuleNotFoundError: No module named 'Crypto'&quot;}],&quot;context&quot;:{&quot;currentFile&quot;:{&quot;path&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;],&quot;content&quot;:&quot;import logging\nlogger = logging.getLogger(__name__)\n\ntry:\n    from cjson import encode as json_encode, decode as json_decode\nexcept ImportError:  # pragma: nocover\n    logger.warn('cjson not found, falling back to stdlib json')\n    from json import loads as json_decode, dumps as json_encode\n\nimport zlib\nimport datetime\n\nfrom base64 import urlsafe_b64encode, urlsafe_b64decode\nfrom collections import namedtuple\nfrom copy import deepcopy\nfrom time import time\nfrom struct import pack\n\nfrom Crypto.Hash import HMAC, SHA256, SHA384, SHA512\nfrom Crypto.Cipher import PKCS1_OAEP, AES\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Random import get_random_bytes\nfrom Crypto.Signature import PKCS1_v1_5 as PKCS1_v1_5_SIG\n\n\n__all__ = ['encrypt', 'decrypt', 'sign', 'verify']\n\n\n# XXX: The attribute order is IMPORTANT in the following namedtuple\n# definitions. DO NOT change them, unless you really know what you're doing.\n\nJWE = namedtuple('JWE',\n    'header '\n    'cek '\n    'iv '\n    'ciphertext '\n    'tag ')\n\nJWS = namedtuple('JWS',\n        'header '\n        'payload '\n        'signature ')\n\nJWT = namedtuple('JWT',\n        'header '\n        'claims ')\n\n\nCLAIM_ISSUER = 'iss'\nCLAIM_SUBJECT = 'sub'\nCLAIM_AUDIENCE = 'aud'\nCLAIM_EXPIRATION_TIME = 'exp'\nCLAIM_NOT_BEFORE = 'nbf'\nCLAIM_ISSUED_AT = 'iat'\nCLAIM_JWT_ID = 'jti'\n\n# these are temporary to allow graceful deprecation of legacy encrypted tokens.\n# these will be removed in v1.0\n_TEMP_VER_KEY = '__v'\n_TEMP_VER = 2\n\n\nclass Error(Exception):\n    \&quot;\&quot;\&quot; The base error type raised by jose\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass Expired(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation if a JWT has expired\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass NotYetValid(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation is a JWT is not yet valid\n    \&quot;\&quot;\&quot;\n    pass\n\n\ndef serialize_compact(jwt):\n    \&quot;\&quot;\&quot; Compact serialization of a :class:`~jose.JWE` or :class:`~jose.JWS`\n\n    :rtype: str\n    :returns: A string, representing the compact serialization of a\n              :class:`~jose.JWE` or :class:`~jose.JWS`.\n    \&quot;\&quot;\&quot;\n    return '.'.join(jwt)\n\n\ndef deserialize_compact(jwt):\n    \&quot;\&quot;\&quot; Deserialization of a compact representation of a :class:`~jwt.JWE`\n\n    :param jwt: The serialized JWT to deserialize.\n    :rtype: :class:`~jose.JWT`.\n    :raises: :class:`~jose.Error` if the JWT is malformed\n    \&quot;\&quot;\&quot;\n    parts = jwt.split('.')\n\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-encryption-23#section-9\n    if len(parts) == 3:\n        token_type = JWS\n    elif len(parts) == 5:\n        token_type = JWE\n    else:\n        raise Error('Malformed JWT')\n\n    return token_type(*parts)\n\n\ndef encrypt(claims, jwk, adata='', add_header=None, alg='RSA-OAEP',\n        enc='A128CBC-HS256', rng=get_random_bytes, compression=None):\n    \&quot;\&quot;\&quot; Encrypts the given claims and produces a :class:`~jose.JWE`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWE`.\n    :param jwk: A `dict` representing the JWK to be used for encryption of\n                the CEK. This parameter is algorithm-specific.\n    :param adata: Arbitrary string data to add to the authentication\n                  (i.e. HMAC). The same data must be provided during\n                  decryption.\n    :param add_header: Additional items to be added to the header. Additional\n                       headers *will* be authenticated.\n    :param alg: The algorithm to use for CEK encryption\n    :param enc: The algorithm to use for claims encryption\n    :param rng: Random number generator. A string of random bytes is expected\n                as output.\n    :param compression: The compression algorithm to use. Currently supports\n                `'DEF'`.\n    :rtype: :class:`~jose.JWE`\n    :raises: :class:`~jose.Error` if there is an error producing the JWE\n    \&quot;\&quot;\&quot;\n    # copy so the injected claim doesn't mutate the input claims\n    # this is a temporary hack to allow for graceful deprecation of tokens,\n    # ensuring that the library can still handle decrypting tokens issued\n    # before the implementation of the fix\n    claims = deepcopy(claims)\n    assert _TEMP_VER_KEY not in claims\n    claims[_TEMP_VER_KEY] = _TEMP_VER\n\n    header = dict((add_header or {}).items() + [\n        ('enc', enc), ('alg', alg)])\n\n    # promote the temp key to the header\n    assert _TEMP_VER_KEY not in header\n    header[_TEMP_VER_KEY] = claims[_TEMP_VER_KEY]\n\n    plaintext = json_encode(claims)\n\n    # compress (if required)\n    if compression is not None:\n        header['zip'] = compression\n        try:\n            (compress, _) = COMPRESSION[compression]\n        except KeyError:\n            raise Error(\n                'Unsupported compression algorithm: {}'.format(compression))\n        plaintext = compress(plaintext)\n\n    # body encryption/hash\n    ((cipher, _), key_size), ((hash_fn, _), hash_mod) = JWA[enc]\n    iv = rng(AES.block_size)\n    encryption_key = rng(hash_mod.digest_size)\n\n    ciphertext = cipher(plaintext, encryption_key[-hash_mod.digest_size/2:], iv)\n    hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata),\n            encryption_key[:-hash_mod.digest_size/2], hash_mod)\n\n    # cek encryption\n    (cipher, _), _ = JWA[alg]\n    encryption_key_ciphertext = cipher(encryption_key, jwk)\n\n    return JWE(*map(b64encode_url,\n            (json_encode(header),\n            encryption_key_ciphertext,\n            iv,\n            ciphertext,\n            auth_tag(hash))))\n\n\ndef decrypt(jwe, jwk, adata='', validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Decrypts a deserialized :class:`~jose.JWE`\n\n    :param jwe: An instance of :class:`~jose.JWE`\n    :param jwk: A `dict` representing the JWK required to decrypt the content\n                of the :class:`~jose.JWE`.\n    :param adata: Arbitrary string data used during encryption for additional\n                  authentication.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, encryption_key_ciphertext, iv, ciphertext, tag = map(\n        b64decode_url, jwe)\n    header = json_decode(header)\n\n    # decrypt cek\n    (_, decipher), _ = JWA[header['alg']]\n    encryption_key = decipher(encryption_key_ciphertext, jwk)\n\n    # decrypt body\n    ((_, decipher), _), ((hash_fn, _), mod) = JWA[header['enc']]\n\n    version = header.get(_TEMP_VER_KEY)\n    if version:\n        plaintext = decipher(ciphertext, encryption_key[-mod.digest_size/2:], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n                encryption_key[:-mod.digest_size/2], mod=mod)\n    else:\n        plaintext = decipher(ciphertext, encryption_key[:-mod.digest_size], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n            encryption_key[-mod.digest_size:], mod=mod)\n\n    if not const_compare(auth_tag(hash), tag):\n        raise Error('Mismatched authentication tags')\n\n    if 'zip' in header:\n        try:\n            (_, decompress) = COMPRESSION[header['zip']]\n        except KeyError:\n            raise Error('Unsupported compression algorithm: {}'.format(\n                header['zip']))\n\n        plaintext = decompress(plaintext)\n\n    claims = json_decode(plaintext)\n    try:\n        del claims[_TEMP_VER_KEY]\n    except KeyError:\n        # expected when decrypting legacy tokens\n        pass\n\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef sign(claims, jwk, add_header=None, alg='HS256'):\n    \&quot;\&quot;\&quot; Signs the given claims and produces a :class:`~jose.JWS`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWS`.\n    :param jwk: A `dict` representing the JWK to be used for signing of the\n                :class:`~jose.JWS`. This parameter is algorithm-specific.\n    :parameter add_header: Additional items to be added to the header.\n                           Additional headers *will* be authenticated.\n    :parameter alg: The algorithm to use to produce the signature.\n    :rtype: :class:`~jose.JWS`\n    \&quot;\&quot;\&quot;\n    (hash_fn, _), mod = JWA[alg]\n\n    header = dict((add_header or {}).items() + [('alg', alg)])\n    header, payload = map(b64encode_url, map(json_encode, (header, claims)))\n\n    sig = b64encode_url(hash_fn(_jws_hash_str(header, payload), jwk['k'],\n        mod=mod))\n\n    return JWS(header, payload, sig)\n\n\ndef verify(jws, jwk, alg, validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Verifies the given :class:`~jose.JWS`\n\n    :param jws: The :class:`~jose.JWS` to be verified.\n    :param jwk: A `dict` representing the JWK to use for verification. This\n                parameter is algorithm-specific.\n    :param alg: The algorithm to verify the signature with.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, payload, sig = map(b64decode_url, jws)\n    header = json_decode(header)\n    if alg != header['alg']:\n        raise Error('Invalid algorithm')\n\n    (_, verify_fn), mod = JWA[header['alg']]\n\n    if not verify_fn(_jws_hash_str(jws.header, jws.payload),\n            jwk['k'], sig, mod=mod):\n        raise Error('Mismatched signatures')\n\n    claims = json_decode(b64decode_url(jws.payload))\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef b64decode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    istr = encode_safe(istr)\n    try:\n        return urlsafe_b64decode(istr + '=' * (4 - (len(istr) % 4)))\n    except TypeError as e:\n        raise Error('Unable to decode base64: %s' % (e))\n\n\ndef b64encode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    return urlsafe_b64encode(encode_safe(istr)).rstrip('=')\n\n\ndef encode_safe(istr, encoding='utf8'):\n    try:\n        return istr.encode(encoding)\n    except UnicodeDecodeError:\n        # this will fail if istr is already encoded\n        pass\n    return istr\n\n\ndef auth_tag(hmac):\n    # http://tools.ietf.org/html/\n    # draft-ietf-oauth-json-web-token-19#section-4.1.4\n    return hmac[:len(hmac) // 2]\n\n\ndef pad_pkcs7(s):\n    sz = AES.block_size - (len(s) % AES.block_size)\n    return s + (chr(sz) * sz)\n\n\ndef unpad_pkcs7(s):\n    return s[:-ord(s[-1])]\n\n\ndef encrypt_oaep(plaintext, jwk):\n    return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).encrypt(plaintext)\n\n\ndef decrypt_oaep(ciphertext, jwk):\n    try:\n        return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).decrypt(ciphertext)\n    except ValueError as e:\n        raise Error(e.args[0])\n\n\ndef hmac_sign(s, key, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n    return hmac.digest()\n\n\ndef hmac_verify(s, key, sig, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n\n    if not const_compare(hmac.digest(), sig):\n        return False\n\n    return True\n\n\ndef rsa_sign(s, key, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).sign(hash)\n\n\ndef rsa_verify(s, key, sig, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).verify(hash, sig)\n\n\ndef encrypt_aescbc(plaintext, key, iv):\n    plaintext = pad_pkcs7(plaintext)\n    return AES.new(key, AES.MODE_CBC, iv).encrypt(plaintext)\n\n\ndef decrypt_aescbc(ciphertext, key, iv):\n    return unpad_pkcs7(AES.new(key, AES.MODE_CBC, iv).decrypt(ciphertext))\n\n\ndef const_compare(stra, strb):\n    if len(stra) != len(strb):\n        return False\n\n    res = 0\n    for a, b in zip(stra, strb):\n        res |= ord(a) ^ ord(b)\n    return res == 0\n\n\nclass _JWA(object):\n    \&quot;\&quot;\&quot; Represents the implemented algorithms\n\n    A big TODO list can be found here:\n    http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-24\n    \&quot;\&quot;\&quot;\n    _impl = {\n        'HS256': ((hmac_sign, hmac_verify), SHA256),\n        'HS384': ((hmac_sign, hmac_verify), SHA384),\n        'HS512': ((hmac_sign, hmac_verify), SHA512),\n        'RS256': ((rsa_sign, rsa_verify), SHA256),\n        'RS384': ((rsa_sign, rsa_verify), SHA384),\n        'RS512': ((rsa_sign, rsa_verify), SHA512),\n        'RSA-OAEP': ((encrypt_oaep, decrypt_oaep), 2048),\n\n        'A128CBC': ((encrypt_aescbc, decrypt_aescbc), 128),\n        'A192CBC': ((encrypt_aescbc, decrypt_aescbc), 192),\n        'A256CBC': ((encrypt_aescbc, decrypt_aescbc), 256),\n    }\n\n    def __getitem__(self, key):\n        \&quot;\&quot;\&quot; Derive implementation(s) from key\n        \&quot;\&quot;\&quot;\n        if key in self._impl:\n            return self._impl[key]\n\n        enc, hash = self._compound_from_key(key)\n        return self._impl[enc], self._impl[hash]\n\n    def _compound_from_key(self, key):\n        try:\n            enc, hash = key.split('+')\n            return enc, hash\n        except ValueError:\n            pass\n\n        try:\n            enc, hash = key.split('-')\n            return enc, hash\n        except ValueError:\n            pass\n\n        raise Error('Unsupported algorithm: {}'.format(key))\n\n\nJWA = _JWA()\n\n\nCOMPRESSION = {\n    'DEF': (zlib.compress, zlib.decompress),\n}\n\n\ndef _format_timestamp(ts):\n    dt = datetime.datetime.utcfromtimestamp(ts)\n    return dt.isoformat() + 'Z'\n\n\ndef _check_expiration_time(now, expiration_time):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if now &gt;= expiration_time:\n        raise Expired('Token expired at {}'.format(\n            _format_timestamp(expiration_time))\n        )\n\n\ndef _check_not_before(now, not_before):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if not_before &gt; now:\n        raise NotYetValid('Token not valid until {}'.format(\n            _format_timestamp(not_before))\n        )\n\n\ndef _validate(claims, validate_claims, expiry_seconds):\n    \&quot;\&quot;\&quot; Validate expiry related claims.\n\n    If validate_claims is False, do nothing.\n\n    Otherwise, validate the exp and nbf claims if they are present, and\n    validate the iat claim if expiry_seconds is provided.\n    \&quot;\&quot;\&quot;\n    if not validate_claims:\n        return\n\n    now = time()\n\n    # TODO: implement support for clock skew\n\n    # The exp (expiration time) claim identifies the expiration time on or\n    # after which the JWT MUST NOT be accepted for processing. The\n    # processing of the exp claim requires that the current date/time MUST\n    # be before the expiration date/time listed in the exp claim.\n    try:\n        expiration_time = claims[CLAIM_EXPIRATION_TIME]\n    except KeyError:\n        pass\n    else:\n        _check_expiration_time(now, expiration_time)\n\n    # The iat (issued at) claim identifies the time at which the JWT was\n    # issued. This claim can be used to determine the age of the JWT.\n    # If expiry_seconds is provided, and the iat claims is present,\n    # determine the age of the token and check if it has expired.\n    try:\n        issued_at = claims[CLAIM_ISSUED_AT]\n    except KeyError:\n        pass\n    else:\n        if expiry_seconds is not None:\n            _check_expiration_time(now, issued_at + expiry_seconds)\n\n    # The nbf (not before) claim identifies the time before which the JWT\n    # MUST NOT be accepted for processing. The processing of the nbf claim\n    # requires that the current date/time MUST be after or equal to the\n    # not-before date/time listed in the nbf claim.\n    try:\n        not_before = claims[CLAIM_NOT_BEFORE]\n    except KeyError:\n        pass\n    else:\n        _check_not_before(now, not_before)\n\n\ndef _jwe_hash_str(ciphertext, iv, adata='', version=_TEMP_VER):\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-algorithms-24#section-5.2.2.1\n    # Both tokens without version and with version 1 should be ignored in\n    # the future as they use incorrect hashing. The version parameter\n    # should also be removed.\n    if not version:\n        return '.'.join((adata, iv, ciphertext, str(len(adata))))\n    elif version == 1:\n        return '.'.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n    return ''.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n\n\ndef _jws_hash_str(header, claims):\n    return '.'.join((header, claims))\n\n\ndef cli_decrypt(jwt, key):\n    print decrypt(deserialize_compact(jwt), {'k':key},\n        validate_claims=False)\n\n\ndef _cli():\n    import inspect\n    import sys\n\n    from argparse import ArgumentParser\n    from copy import copy\n\n    parser = ArgumentParser()\n    subparsers = parser.add_subparsers(dest='subparser_name')\n\n    commands = {\n        'decrypt': cli_decrypt,\n    }\n    for k, fn in commands.items():\n        p = subparsers.add_parser(k)\n        for arg in inspect.getargspec(fn).args:\n            p.add_argument(arg)\n\n    args = parser.parse_args()\n    handler = commands[args.subparser_name]\n    handler_args = [getattr(args, k) for k in inspect.getargspec(\n        handler).args]\n    handler(*handler_args)\n&quot;},&quot;codebaseEnabled&quot;:true,&quot;ragFiles&quot;:[{&quot;path&quot;:&quot;core/security.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\security.py&quot;,&quot;sources&quot;:[&quot;keyword_search&quot;]},{&quot;path&quot;:&quot;core\\config.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\config.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;__init__.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\__init__.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\database.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\database.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;agents\\job_creator_agent.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\agents\\job_creator_agent.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;main.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;pyproject.toml&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\pyproject.toml&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;README.md&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\README.md&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;.gitignore&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.gitignore&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;alembic\\alembic.ini&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\alembic\\alembic.ini&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;services\\auth_service.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\services\\auth_service.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\security.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\security.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;models/models.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\models\\models.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;core/security.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\security.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;models/organization.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\models\\organization.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;schemas/auth.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\schemas\\auth.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;schemas/schemas.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\schemas\\schemas.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;services/auth_service.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\services\\auth_service.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;__init__.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\__init__.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;main.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;.env&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.env&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;.venv/Lib/site-packages/jose.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]}],&quot;rerankedFiles&quot;:[{&quot;path&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;,&quot;fsPath&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;}],&quot;usedFilePaths&quot;:[{&quot;path&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;],&quot;content&quot;:&quot;import logging\nlogger = logging.getLogger(__name__)\n\ntry:\n    from cjson import encode as json_encode, decode as json_decode\nexcept ImportError:  # pragma: nocover\n    logger.warn('cjson not found, falling back to stdlib json')\n    from json import loads as json_decode, dumps as json_encode\n\nimport zlib\nimport datetime\n\nfrom base64 import urlsafe_b64encode, urlsafe_b64decode\nfrom collections import namedtuple\nfrom copy import deepcopy\nfrom time import time\nfrom struct import pack\n\nfrom Crypto.Hash import HMAC, SHA256, SHA384, SHA512\nfrom Crypto.Cipher import PKCS1_OAEP, AES\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Random import get_random_bytes\nfrom Crypto.Signature import PKCS1_v1_5 as PKCS1_v1_5_SIG\n\n\n__all__ = ['encrypt', 'decrypt', 'sign', 'verify']\n\n\n# XXX: The attribute order is IMPORTANT in the following namedtuple\n# definitions. DO NOT change them, unless you really know what you're doing.\n\nJWE = namedtuple('JWE',\n    'header '\n    'cek '\n    'iv '\n    'ciphertext '\n    'tag ')\n\nJWS = namedtuple('JWS',\n        'header '\n        'payload '\n        'signature ')\n\nJWT = namedtuple('JWT',\n        'header '\n        'claims ')\n\n\nCLAIM_ISSUER = 'iss'\nCLAIM_SUBJECT = 'sub'\nCLAIM_AUDIENCE = 'aud'\nCLAIM_EXPIRATION_TIME = 'exp'\nCLAIM_NOT_BEFORE = 'nbf'\nCLAIM_ISSUED_AT = 'iat'\nCLAIM_JWT_ID = 'jti'\n\n# these are temporary to allow graceful deprecation of legacy encrypted tokens.\n# these will be removed in v1.0\n_TEMP_VER_KEY = '__v'\n_TEMP_VER = 2\n\n\nclass Error(Exception):\n    \&quot;\&quot;\&quot; The base error type raised by jose\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass Expired(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation if a JWT has expired\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass NotYetValid(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation is a JWT is not yet valid\n    \&quot;\&quot;\&quot;\n    pass\n\n\ndef serialize_compact(jwt):\n    \&quot;\&quot;\&quot; Compact serialization of a :class:`~jose.JWE` or :class:`~jose.JWS`\n\n    :rtype: str\n    :returns: A string, representing the compact serialization of a\n              :class:`~jose.JWE` or :class:`~jose.JWS`.\n    \&quot;\&quot;\&quot;\n    return '.'.join(jwt)\n\n\ndef deserialize_compact(jwt):\n    \&quot;\&quot;\&quot; Deserialization of a compact representation of a :class:`~jwt.JWE`\n\n    :param jwt: The serialized JWT to deserialize.\n    :rtype: :class:`~jose.JWT`.\n    :raises: :class:`~jose.Error` if the JWT is malformed\n    \&quot;\&quot;\&quot;\n    parts = jwt.split('.')\n\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-encryption-23#section-9\n    if len(parts) == 3:\n        token_type = JWS\n    elif len(parts) == 5:\n        token_type = JWE\n    else:\n        raise Error('Malformed JWT')\n\n    return token_type(*parts)\n\n\ndef encrypt(claims, jwk, adata='', add_header=None, alg='RSA-OAEP',\n        enc='A128CBC-HS256', rng=get_random_bytes, compression=None):\n    \&quot;\&quot;\&quot; Encrypts the given claims and produces a :class:`~jose.JWE`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWE`.\n    :param jwk: A `dict` representing the JWK to be used for encryption of\n                the CEK. This parameter is algorithm-specific.\n    :param adata: Arbitrary string data to add to the authentication\n                  (i.e. HMAC). The same data must be provided during\n                  decryption.\n    :param add_header: Additional items to be added to the header. Additional\n                       headers *will* be authenticated.\n    :param alg: The algorithm to use for CEK encryption\n    :param enc: The algorithm to use for claims encryption\n    :param rng: Random number generator. A string of random bytes is expected\n                as output.\n    :param compression: The compression algorithm to use. Currently supports\n                `'DEF'`.\n    :rtype: :class:`~jose.JWE`\n    :raises: :class:`~jose.Error` if there is an error producing the JWE\n    \&quot;\&quot;\&quot;\n    # copy so the injected claim doesn't mutate the input claims\n    # this is a temporary hack to allow for graceful deprecation of tokens,\n    # ensuring that the library can still handle decrypting tokens issued\n    # before the implementation of the fix\n    claims = deepcopy(claims)\n    assert _TEMP_VER_KEY not in claims\n    claims[_TEMP_VER_KEY] = _TEMP_VER\n\n    header = dict((add_header or {}).items() + [\n        ('enc', enc), ('alg', alg)])\n\n    # promote the temp key to the header\n    assert _TEMP_VER_KEY not in header\n    header[_TEMP_VER_KEY] = claims[_TEMP_VER_KEY]\n\n    plaintext = json_encode(claims)\n\n    # compress (if required)\n    if compression is not None:\n        header['zip'] = compression\n        try:\n            (compress, _) = COMPRESSION[compression]\n        except KeyError:\n            raise Error(\n                'Unsupported compression algorithm: {}'.format(compression))\n        plaintext = compress(plaintext)\n\n    # body encryption/hash\n    ((cipher, _), key_size), ((hash_fn, _), hash_mod) = JWA[enc]\n    iv = rng(AES.block_size)\n    encryption_key = rng(hash_mod.digest_size)\n\n    ciphertext = cipher(plaintext, encryption_key[-hash_mod.digest_size/2:], iv)\n    hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata),\n            encryption_key[:-hash_mod.digest_size/2], hash_mod)\n\n    # cek encryption\n    (cipher, _), _ = JWA[alg]\n    encryption_key_ciphertext = cipher(encryption_key, jwk)\n\n    return JWE(*map(b64encode_url,\n            (json_encode(header),\n            encryption_key_ciphertext,\n            iv,\n            ciphertext,\n            auth_tag(hash))))\n\n\ndef decrypt(jwe, jwk, adata='', validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Decrypts a deserialized :class:`~jose.JWE`\n\n    :param jwe: An instance of :class:`~jose.JWE`\n    :param jwk: A `dict` representing the JWK required to decrypt the content\n                of the :class:`~jose.JWE`.\n    :param adata: Arbitrary string data used during encryption for additional\n                  authentication.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, encryption_key_ciphertext, iv, ciphertext, tag = map(\n        b64decode_url, jwe)\n    header = json_decode(header)\n\n    # decrypt cek\n    (_, decipher), _ = JWA[header['alg']]\n    encryption_key = decipher(encryption_key_ciphertext, jwk)\n\n    # decrypt body\n    ((_, decipher), _), ((hash_fn, _), mod) = JWA[header['enc']]\n\n    version = header.get(_TEMP_VER_KEY)\n    if version:\n        plaintext = decipher(ciphertext, encryption_key[-mod.digest_size/2:], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n                encryption_key[:-mod.digest_size/2], mod=mod)\n    else:\n        plaintext = decipher(ciphertext, encryption_key[:-mod.digest_size], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n            encryption_key[-mod.digest_size:], mod=mod)\n\n    if not const_compare(auth_tag(hash), tag):\n        raise Error('Mismatched authentication tags')\n\n    if 'zip' in header:\n        try:\n            (_, decompress) = COMPRESSION[header['zip']]\n        except KeyError:\n            raise Error('Unsupported compression algorithm: {}'.format(\n                header['zip']))\n\n        plaintext = decompress(plaintext)\n\n    claims = json_decode(plaintext)\n    try:\n        del claims[_TEMP_VER_KEY]\n    except KeyError:\n        # expected when decrypting legacy tokens\n        pass\n\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef sign(claims, jwk, add_header=None, alg='HS256'):\n    \&quot;\&quot;\&quot; Signs the given claims and produces a :class:`~jose.JWS`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWS`.\n    :param jwk: A `dict` representing the JWK to be used for signing of the\n                :class:`~jose.JWS`. This parameter is algorithm-specific.\n    :parameter add_header: Additional items to be added to the header.\n                           Additional headers *will* be authenticated.\n    :parameter alg: The algorithm to use to produce the signature.\n    :rtype: :class:`~jose.JWS`\n    \&quot;\&quot;\&quot;\n    (hash_fn, _), mod = JWA[alg]\n\n    header = dict((add_header or {}).items() + [('alg', alg)])\n    header, payload = map(b64encode_url, map(json_encode, (header, claims)))\n\n    sig = b64encode_url(hash_fn(_jws_hash_str(header, payload), jwk['k'],\n        mod=mod))\n\n    return JWS(header, payload, sig)\n\n\ndef verify(jws, jwk, alg, validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Verifies the given :class:`~jose.JWS`\n\n    :param jws: The :class:`~jose.JWS` to be verified.\n    :param jwk: A `dict` representing the JWK to use for verification. This\n                parameter is algorithm-specific.\n    :param alg: The algorithm to verify the signature with.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, payload, sig = map(b64decode_url, jws)\n    header = json_decode(header)\n    if alg != header['alg']:\n        raise Error('Invalid algorithm')\n\n    (_, verify_fn), mod = JWA[header['alg']]\n\n    if not verify_fn(_jws_hash_str(jws.header, jws.payload),\n            jwk['k'], sig, mod=mod):\n        raise Error('Mismatched signatures')\n\n    claims = json_decode(b64decode_url(jws.payload))\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef b64decode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    istr = encode_safe(istr)\n    try:\n        return urlsafe_b64decode(istr + '=' * (4 - (len(istr) % 4)))\n    except TypeError as e:\n        raise Error('Unable to decode base64: %s' % (e))\n\n\ndef b64encode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    return urlsafe_b64encode(encode_safe(istr)).rstrip('=')\n\n\ndef encode_safe(istr, encoding='utf8'):\n    try:\n        return istr.encode(encoding)\n    except UnicodeDecodeError:\n        # this will fail if istr is already encoded\n        pass\n    return istr\n\n\ndef auth_tag(hmac):\n    # http://tools.ietf.org/html/\n    # draft-ietf-oauth-json-web-token-19#section-4.1.4\n    return hmac[:len(hmac) // 2]\n\n\ndef pad_pkcs7(s):\n    sz = AES.block_size - (len(s) % AES.block_size)\n    return s + (chr(sz) * sz)\n\n\ndef unpad_pkcs7(s):\n    return s[:-ord(s[-1])]\n\n\ndef encrypt_oaep(plaintext, jwk):\n    return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).encrypt(plaintext)\n\n\ndef decrypt_oaep(ciphertext, jwk):\n    try:\n        return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).decrypt(ciphertext)\n    except ValueError as e:\n        raise Error(e.args[0])\n\n\ndef hmac_sign(s, key, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n    return hmac.digest()\n\n\ndef hmac_verify(s, key, sig, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n\n    if not const_compare(hmac.digest(), sig):\n        return False\n\n    return True\n\n\ndef rsa_sign(s, key, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).sign(hash)\n\n\ndef rsa_verify(s, key, sig, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).verify(hash, sig)\n\n\ndef encrypt_aescbc(plaintext, key, iv):\n    plaintext = pad_pkcs7(plaintext)\n    return AES.new(key, AES.MODE_CBC, iv).encrypt(plaintext)\n\n\ndef decrypt_aescbc(ciphertext, key, iv):\n    return unpad_pkcs7(AES.new(key, AES.MODE_CBC, iv).decrypt(ciphertext))\n\n\ndef const_compare(stra, strb):\n    if len(stra) != len(strb):\n        return False\n\n    res = 0\n    for a, b in zip(stra, strb):\n        res |= ord(a) ^ ord(b)\n    return res == 0\n\n\nclass _JWA(object):\n    \&quot;\&quot;\&quot; Represents the implemented algorithms\n\n    A big TODO list can be found here:\n    http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-24\n    \&quot;\&quot;\&quot;\n    _impl = {\n        'HS256': ((hmac_sign, hmac_verify), SHA256),\n        'HS384': ((hmac_sign, hmac_verify), SHA384),\n        'HS512': ((hmac_sign, hmac_verify), SHA512),\n        'RS256': ((rsa_sign, rsa_verify), SHA256),\n        'RS384': ((rsa_sign, rsa_verify), SHA384),\n        'RS512': ((rsa_sign, rsa_verify), SHA512),\n        'RSA-OAEP': ((encrypt_oaep, decrypt_oaep), 2048),\n\n        'A128CBC': ((encrypt_aescbc, decrypt_aescbc), 128),\n        'A192CBC': ((encrypt_aescbc, decrypt_aescbc), 192),\n        'A256CBC': ((encrypt_aescbc, decrypt_aescbc), 256),\n    }\n\n    def __getitem__(self, key):\n        \&quot;\&quot;\&quot; Derive implementation(s) from key\n        \&quot;\&quot;\&quot;\n        if key in self._impl:\n            return self._impl[key]\n\n        enc, hash = self._compound_from_key(key)\n        return self._impl[enc], self._impl[hash]\n\n    def _compound_from_key(self, key):\n        try:\n            enc, hash = key.split('+')\n            return enc, hash\n        except ValueError:\n            pass\n\n        try:\n            enc, hash = key.split('-')\n            return enc, hash\n        except ValueError:\n            pass\n\n        raise Error('Unsupported algorithm: {}'.format(key))\n\n\nJWA = _JWA()\n\n\nCOMPRESSION = {\n    'DEF': (zlib.compress, zlib.decompress),\n}\n\n\ndef _format_timestamp(ts):\n    dt = datetime.datetime.utcfromtimestamp(ts)\n    return dt.isoformat() + 'Z'\n\n\ndef _check_expiration_time(now, expiration_time):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if now &gt;= expiration_time:\n        raise Expired('Token expired at {}'.format(\n            _format_timestamp(expiration_time))\n        )\n\n\ndef _check_not_before(now, not_before):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if not_before &gt; now:\n        raise NotYetValid('Token not valid until {}'.format(\n            _format_timestamp(not_before))\n        )\n\n\ndef _validate(claims, validate_claims, expiry_seconds):\n    \&quot;\&quot;\&quot; Validate expiry related claims.\n\n    If validate_claims is False, do nothing.\n\n    Otherwise, validate the exp and nbf claims if they are present, and\n    validate the iat claim if expiry_seconds is provided.\n    \&quot;\&quot;\&quot;\n    if not validate_claims:\n        return\n\n    now = time()\n\n    # TODO: implement support for clock skew\n\n    # The exp (expiration time) claim identifies the expiration time on or\n    # after which the JWT MUST NOT be accepted for processing. The\n    # processing of the exp claim requires that the current date/time MUST\n    # be before the expiration date/time listed in the exp claim.\n    try:\n        expiration_time = claims[CLAIM_EXPIRATION_TIME]\n    except KeyError:\n        pass\n    else:\n        _check_expiration_time(now, expiration_time)\n\n    # The iat (issued at) claim identifies the time at which the JWT was\n    # issued. This claim can be used to determine the age of the JWT.\n    # If expiry_seconds is provided, and the iat claims is present,\n    # determine the age of the token and check if it has expired.\n    try:\n        issued_at = claims[CLAIM_ISSUED_AT]\n    except KeyError:\n        pass\n    else:\n        if expiry_seconds is not None:\n            _check_expiration_time(now, issued_at + expiry_seconds)\n\n    # The nbf (not before) claim identifies the time before which the JWT\n    # MUST NOT be accepted for processing. The processing of the nbf claim\n    # requires that the current date/time MUST be after or equal to the\n    # not-before date/time listed in the nbf claim.\n    try:\n        not_before = claims[CLAIM_NOT_BEFORE]\n    except KeyError:\n        pass\n    else:\n        _check_not_before(now, not_before)\n\n\ndef _jwe_hash_str(ciphertext, iv, adata='', version=_TEMP_VER):\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-algorithms-24#section-5.2.2.1\n    # Both tokens without version and with version 1 should be ignored in\n    # the future as they use incorrect hashing. The version parameter\n    # should also be removed.\n    if not version:\n        return '.'.join((adata, iv, ciphertext, str(len(adata))))\n    elif version == 1:\n        return '.'.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n    return ''.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n\n\ndef _jws_hash_str(header, claims):\n    return '.'.join((header, claims))\n\n\ndef cli_decrypt(jwt, key):\n    print decrypt(deserialize_compact(jwt), {'k':key},\n        validate_claims=False)\n\n\ndef _cli():\n    import inspect\n    import sys\n\n    from argparse import ArgumentParser\n    from copy import copy\n\n    parser = ArgumentParser()\n    subparsers = parser.add_subparsers(dest='subparser_name')\n\n    commands = {\n        'decrypt': cli_decrypt,\n    }\n    for k, fn in commands.items():\n        p = subparsers.add_parser(k)\n        for arg in inspect.getargspec(fn).args:\n            p.add_argument(arg)\n\n    args = parser.parse_args()\n    handler = commands[args.subparser_name]\n    handler_args = [getattr(args, k) for k in inspect.getargspec(\n        handler).args]\n    handler(*handler_args)\n&quot;}]},&quot;createdAt&quot;:1751746538888,&quot;isInternal&quot;:false,&quot;rawContent&quot;:{&quot;type&quot;:&quot;doc&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;why this errors:&quot;}]},{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py:7: DeprecationWarning: The 'warn' method is deprecated, use 'warning' instead&quot;}]},{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;  logger.warn('cjson not found, falling back to stdlib json')&quot;}]},{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;cjson not found, falling back to stdlib json&quot;}]},{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Traceback (most recent call last):&quot;}]},{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;  File \&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py\&quot;, line 19, in &lt;module&gt;&quot;}]},{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;    from Crypto.Hash import HMAC, SHA256, SHA384, SHA512&quot;}]},{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;ModuleNotFoundError: No module named 'Crypto'&quot;}]}]}},{&quot;id&quot;:&quot;acf0001d-9f84-4afd-9c1a-8fa083339e94&quot;,&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;The errors you're encountering are due to two main issues in your Python script:\n\n1. **DeprecationWarning**: \n   - The warning message `DeprecationWarning: The 'warn' method is deprecated, use 'warning' instead` indicates that the `warn` method of the logger is deprecated. You should replace `logger.warn` with `logger.warning` in your code. This change is necessary because the `warn` method has been deprecated in favor of `warning` in the Python logging module.\n\n   **Solution**: Update the line in your code from:\n   ```python\n   logger.warn('cjson not found, falling back to stdlib json')\n   ```\n   to:\n   ```python\n   logger.warning('cjson not found, falling back to stdlib json')\n   ```\n\n2. **ModuleNotFoundError**:\n   - The error `ModuleNotFoundError: No module named 'Crypto'` indicates that the `pycryptodome` library, which provides the `Crypto` module, is not installed in your virtual environment.\n\n   **Solution**: You need to install the `pycryptodome` package. You can do this by running the following command in your terminal:\n   ```bash\n   pip install pycryptodome\n   ```\n\nAfter making these changes, your script should work without these errors. Make sure your virtual environment is activated when you install the package.&quot;}],&quot;context&quot;:{&quot;currentFile&quot;:{&quot;path&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;],&quot;content&quot;:&quot;import logging\nlogger = logging.getLogger(__name__)\n\ntry:\n    from cjson import encode as json_encode, decode as json_decode\nexcept ImportError:  # pragma: nocover\n    logger.warn('cjson not found, falling back to stdlib json')\n    from json import loads as json_decode, dumps as json_encode\n\nimport zlib\nimport datetime\n\nfrom base64 import urlsafe_b64encode, urlsafe_b64decode\nfrom collections import namedtuple\nfrom copy import deepcopy\nfrom time import time\nfrom struct import pack\n\nfrom Crypto.Hash import HMAC, SHA256, SHA384, SHA512\nfrom Crypto.Cipher import PKCS1_OAEP, AES\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Random import get_random_bytes\nfrom Crypto.Signature import PKCS1_v1_5 as PKCS1_v1_5_SIG\n\n\n__all__ = ['encrypt', 'decrypt', 'sign', 'verify']\n\n\n# XXX: The attribute order is IMPORTANT in the following namedtuple\n# definitions. DO NOT change them, unless you really know what you're doing.\n\nJWE = namedtuple('JWE',\n    'header '\n    'cek '\n    'iv '\n    'ciphertext '\n    'tag ')\n\nJWS = namedtuple('JWS',\n        'header '\n        'payload '\n        'signature ')\n\nJWT = namedtuple('JWT',\n        'header '\n        'claims ')\n\n\nCLAIM_ISSUER = 'iss'\nCLAIM_SUBJECT = 'sub'\nCLAIM_AUDIENCE = 'aud'\nCLAIM_EXPIRATION_TIME = 'exp'\nCLAIM_NOT_BEFORE = 'nbf'\nCLAIM_ISSUED_AT = 'iat'\nCLAIM_JWT_ID = 'jti'\n\n# these are temporary to allow graceful deprecation of legacy encrypted tokens.\n# these will be removed in v1.0\n_TEMP_VER_KEY = '__v'\n_TEMP_VER = 2\n\n\nclass Error(Exception):\n    \&quot;\&quot;\&quot; The base error type raised by jose\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass Expired(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation if a JWT has expired\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass NotYetValid(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation is a JWT is not yet valid\n    \&quot;\&quot;\&quot;\n    pass\n\n\ndef serialize_compact(jwt):\n    \&quot;\&quot;\&quot; Compact serialization of a :class:`~jose.JWE` or :class:`~jose.JWS`\n\n    :rtype: str\n    :returns: A string, representing the compact serialization of a\n              :class:`~jose.JWE` or :class:`~jose.JWS`.\n    \&quot;\&quot;\&quot;\n    return '.'.join(jwt)\n\n\ndef deserialize_compact(jwt):\n    \&quot;\&quot;\&quot; Deserialization of a compact representation of a :class:`~jwt.JWE`\n\n    :param jwt: The serialized JWT to deserialize.\n    :rtype: :class:`~jose.JWT`.\n    :raises: :class:`~jose.Error` if the JWT is malformed\n    \&quot;\&quot;\&quot;\n    parts = jwt.split('.')\n\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-encryption-23#section-9\n    if len(parts) == 3:\n        token_type = JWS\n    elif len(parts) == 5:\n        token_type = JWE\n    else:\n        raise Error('Malformed JWT')\n\n    return token_type(*parts)\n\n\ndef encrypt(claims, jwk, adata='', add_header=None, alg='RSA-OAEP',\n        enc='A128CBC-HS256', rng=get_random_bytes, compression=None):\n    \&quot;\&quot;\&quot; Encrypts the given claims and produces a :class:`~jose.JWE`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWE`.\n    :param jwk: A `dict` representing the JWK to be used for encryption of\n                the CEK. This parameter is algorithm-specific.\n    :param adata: Arbitrary string data to add to the authentication\n                  (i.e. HMAC). The same data must be provided during\n                  decryption.\n    :param add_header: Additional items to be added to the header. Additional\n                       headers *will* be authenticated.\n    :param alg: The algorithm to use for CEK encryption\n    :param enc: The algorithm to use for claims encryption\n    :param rng: Random number generator. A string of random bytes is expected\n                as output.\n    :param compression: The compression algorithm to use. Currently supports\n                `'DEF'`.\n    :rtype: :class:`~jose.JWE`\n    :raises: :class:`~jose.Error` if there is an error producing the JWE\n    \&quot;\&quot;\&quot;\n    # copy so the injected claim doesn't mutate the input claims\n    # this is a temporary hack to allow for graceful deprecation of tokens,\n    # ensuring that the library can still handle decrypting tokens issued\n    # before the implementation of the fix\n    claims = deepcopy(claims)\n    assert _TEMP_VER_KEY not in claims\n    claims[_TEMP_VER_KEY] = _TEMP_VER\n\n    header = dict((add_header or {}).items() + [\n        ('enc', enc), ('alg', alg)])\n\n    # promote the temp key to the header\n    assert _TEMP_VER_KEY not in header\n    header[_TEMP_VER_KEY] = claims[_TEMP_VER_KEY]\n\n    plaintext = json_encode(claims)\n\n    # compress (if required)\n    if compression is not None:\n        header['zip'] = compression\n        try:\n            (compress, _) = COMPRESSION[compression]\n        except KeyError:\n            raise Error(\n                'Unsupported compression algorithm: {}'.format(compression))\n        plaintext = compress(plaintext)\n\n    # body encryption/hash\n    ((cipher, _), key_size), ((hash_fn, _), hash_mod) = JWA[enc]\n    iv = rng(AES.block_size)\n    encryption_key = rng(hash_mod.digest_size)\n\n    ciphertext = cipher(plaintext, encryption_key[-hash_mod.digest_size/2:], iv)\n    hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata),\n            encryption_key[:-hash_mod.digest_size/2], hash_mod)\n\n    # cek encryption\n    (cipher, _), _ = JWA[alg]\n    encryption_key_ciphertext = cipher(encryption_key, jwk)\n\n    return JWE(*map(b64encode_url,\n            (json_encode(header),\n            encryption_key_ciphertext,\n            iv,\n            ciphertext,\n            auth_tag(hash))))\n\n\ndef decrypt(jwe, jwk, adata='', validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Decrypts a deserialized :class:`~jose.JWE`\n\n    :param jwe: An instance of :class:`~jose.JWE`\n    :param jwk: A `dict` representing the JWK required to decrypt the content\n                of the :class:`~jose.JWE`.\n    :param adata: Arbitrary string data used during encryption for additional\n                  authentication.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, encryption_key_ciphertext, iv, ciphertext, tag = map(\n        b64decode_url, jwe)\n    header = json_decode(header)\n\n    # decrypt cek\n    (_, decipher), _ = JWA[header['alg']]\n    encryption_key = decipher(encryption_key_ciphertext, jwk)\n\n    # decrypt body\n    ((_, decipher), _), ((hash_fn, _), mod) = JWA[header['enc']]\n\n    version = header.get(_TEMP_VER_KEY)\n    if version:\n        plaintext = decipher(ciphertext, encryption_key[-mod.digest_size/2:], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n                encryption_key[:-mod.digest_size/2], mod=mod)\n    else:\n        plaintext = decipher(ciphertext, encryption_key[:-mod.digest_size], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n            encryption_key[-mod.digest_size:], mod=mod)\n\n    if not const_compare(auth_tag(hash), tag):\n        raise Error('Mismatched authentication tags')\n\n    if 'zip' in header:\n        try:\n            (_, decompress) = COMPRESSION[header['zip']]\n        except KeyError:\n            raise Error('Unsupported compression algorithm: {}'.format(\n                header['zip']))\n\n        plaintext = decompress(plaintext)\n\n    claims = json_decode(plaintext)\n    try:\n        del claims[_TEMP_VER_KEY]\n    except KeyError:\n        # expected when decrypting legacy tokens\n        pass\n\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef sign(claims, jwk, add_header=None, alg='HS256'):\n    \&quot;\&quot;\&quot; Signs the given claims and produces a :class:`~jose.JWS`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWS`.\n    :param jwk: A `dict` representing the JWK to be used for signing of the\n                :class:`~jose.JWS`. This parameter is algorithm-specific.\n    :parameter add_header: Additional items to be added to the header.\n                           Additional headers *will* be authenticated.\n    :parameter alg: The algorithm to use to produce the signature.\n    :rtype: :class:`~jose.JWS`\n    \&quot;\&quot;\&quot;\n    (hash_fn, _), mod = JWA[alg]\n\n    header = dict((add_header or {}).items() + [('alg', alg)])\n    header, payload = map(b64encode_url, map(json_encode, (header, claims)))\n\n    sig = b64encode_url(hash_fn(_jws_hash_str(header, payload), jwk['k'],\n        mod=mod))\n\n    return JWS(header, payload, sig)\n\n\ndef verify(jws, jwk, alg, validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Verifies the given :class:`~jose.JWS`\n\n    :param jws: The :class:`~jose.JWS` to be verified.\n    :param jwk: A `dict` representing the JWK to use for verification. This\n                parameter is algorithm-specific.\n    :param alg: The algorithm to verify the signature with.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, payload, sig = map(b64decode_url, jws)\n    header = json_decode(header)\n    if alg != header['alg']:\n        raise Error('Invalid algorithm')\n\n    (_, verify_fn), mod = JWA[header['alg']]\n\n    if not verify_fn(_jws_hash_str(jws.header, jws.payload),\n            jwk['k'], sig, mod=mod):\n        raise Error('Mismatched signatures')\n\n    claims = json_decode(b64decode_url(jws.payload))\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef b64decode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    istr = encode_safe(istr)\n    try:\n        return urlsafe_b64decode(istr + '=' * (4 - (len(istr) % 4)))\n    except TypeError as e:\n        raise Error('Unable to decode base64: %s' % (e))\n\n\ndef b64encode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    return urlsafe_b64encode(encode_safe(istr)).rstrip('=')\n\n\ndef encode_safe(istr, encoding='utf8'):\n    try:\n        return istr.encode(encoding)\n    except UnicodeDecodeError:\n        # this will fail if istr is already encoded\n        pass\n    return istr\n\n\ndef auth_tag(hmac):\n    # http://tools.ietf.org/html/\n    # draft-ietf-oauth-json-web-token-19#section-4.1.4\n    return hmac[:len(hmac) // 2]\n\n\ndef pad_pkcs7(s):\n    sz = AES.block_size - (len(s) % AES.block_size)\n    return s + (chr(sz) * sz)\n\n\ndef unpad_pkcs7(s):\n    return s[:-ord(s[-1])]\n\n\ndef encrypt_oaep(plaintext, jwk):\n    return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).encrypt(plaintext)\n\n\ndef decrypt_oaep(ciphertext, jwk):\n    try:\n        return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).decrypt(ciphertext)\n    except ValueError as e:\n        raise Error(e.args[0])\n\n\ndef hmac_sign(s, key, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n    return hmac.digest()\n\n\ndef hmac_verify(s, key, sig, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n\n    if not const_compare(hmac.digest(), sig):\n        return False\n\n    return True\n\n\ndef rsa_sign(s, key, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).sign(hash)\n\n\ndef rsa_verify(s, key, sig, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).verify(hash, sig)\n\n\ndef encrypt_aescbc(plaintext, key, iv):\n    plaintext = pad_pkcs7(plaintext)\n    return AES.new(key, AES.MODE_CBC, iv).encrypt(plaintext)\n\n\ndef decrypt_aescbc(ciphertext, key, iv):\n    return unpad_pkcs7(AES.new(key, AES.MODE_CBC, iv).decrypt(ciphertext))\n\n\ndef const_compare(stra, strb):\n    if len(stra) != len(strb):\n        return False\n\n    res = 0\n    for a, b in zip(stra, strb):\n        res |= ord(a) ^ ord(b)\n    return res == 0\n\n\nclass _JWA(object):\n    \&quot;\&quot;\&quot; Represents the implemented algorithms\n\n    A big TODO list can be found here:\n    http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-24\n    \&quot;\&quot;\&quot;\n    _impl = {\n        'HS256': ((hmac_sign, hmac_verify), SHA256),\n        'HS384': ((hmac_sign, hmac_verify), SHA384),\n        'HS512': ((hmac_sign, hmac_verify), SHA512),\n        'RS256': ((rsa_sign, rsa_verify), SHA256),\n        'RS384': ((rsa_sign, rsa_verify), SHA384),\n        'RS512': ((rsa_sign, rsa_verify), SHA512),\n        'RSA-OAEP': ((encrypt_oaep, decrypt_oaep), 2048),\n\n        'A128CBC': ((encrypt_aescbc, decrypt_aescbc), 128),\n        'A192CBC': ((encrypt_aescbc, decrypt_aescbc), 192),\n        'A256CBC': ((encrypt_aescbc, decrypt_aescbc), 256),\n    }\n\n    def __getitem__(self, key):\n        \&quot;\&quot;\&quot; Derive implementation(s) from key\n        \&quot;\&quot;\&quot;\n        if key in self._impl:\n            return self._impl[key]\n\n        enc, hash = self._compound_from_key(key)\n        return self._impl[enc], self._impl[hash]\n\n    def _compound_from_key(self, key):\n        try:\n            enc, hash = key.split('+')\n            return enc, hash\n        except ValueError:\n            pass\n\n        try:\n            enc, hash = key.split('-')\n            return enc, hash\n        except ValueError:\n            pass\n\n        raise Error('Unsupported algorithm: {}'.format(key))\n\n\nJWA = _JWA()\n\n\nCOMPRESSION = {\n    'DEF': (zlib.compress, zlib.decompress),\n}\n\n\ndef _format_timestamp(ts):\n    dt = datetime.datetime.utcfromtimestamp(ts)\n    return dt.isoformat() + 'Z'\n\n\ndef _check_expiration_time(now, expiration_time):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if now &gt;= expiration_time:\n        raise Expired('Token expired at {}'.format(\n            _format_timestamp(expiration_time))\n        )\n\n\ndef _check_not_before(now, not_before):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if not_before &gt; now:\n        raise NotYetValid('Token not valid until {}'.format(\n            _format_timestamp(not_before))\n        )\n\n\ndef _validate(claims, validate_claims, expiry_seconds):\n    \&quot;\&quot;\&quot; Validate expiry related claims.\n\n    If validate_claims is False, do nothing.\n\n    Otherwise, validate the exp and nbf claims if they are present, and\n    validate the iat claim if expiry_seconds is provided.\n    \&quot;\&quot;\&quot;\n    if not validate_claims:\n        return\n\n    now = time()\n\n    # TODO: implement support for clock skew\n\n    # The exp (expiration time) claim identifies the expiration time on or\n    # after which the JWT MUST NOT be accepted for processing. The\n    # processing of the exp claim requires that the current date/time MUST\n    # be before the expiration date/time listed in the exp claim.\n    try:\n        expiration_time = claims[CLAIM_EXPIRATION_TIME]\n    except KeyError:\n        pass\n    else:\n        _check_expiration_time(now, expiration_time)\n\n    # The iat (issued at) claim identifies the time at which the JWT was\n    # issued. This claim can be used to determine the age of the JWT.\n    # If expiry_seconds is provided, and the iat claims is present,\n    # determine the age of the token and check if it has expired.\n    try:\n        issued_at = claims[CLAIM_ISSUED_AT]\n    except KeyError:\n        pass\n    else:\n        if expiry_seconds is not None:\n            _check_expiration_time(now, issued_at + expiry_seconds)\n\n    # The nbf (not before) claim identifies the time before which the JWT\n    # MUST NOT be accepted for processing. The processing of the nbf claim\n    # requires that the current date/time MUST be after or equal to the\n    # not-before date/time listed in the nbf claim.\n    try:\n        not_before = claims[CLAIM_NOT_BEFORE]\n    except KeyError:\n        pass\n    else:\n        _check_not_before(now, not_before)\n\n\ndef _jwe_hash_str(ciphertext, iv, adata='', version=_TEMP_VER):\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-algorithms-24#section-5.2.2.1\n    # Both tokens without version and with version 1 should be ignored in\n    # the future as they use incorrect hashing. The version parameter\n    # should also be removed.\n    if not version:\n        return '.'.join((adata, iv, ciphertext, str(len(adata))))\n    elif version == 1:\n        return '.'.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n    return ''.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n\n\ndef _jws_hash_str(header, claims):\n    return '.'.join((header, claims))\n\n\ndef cli_decrypt(jwt, key):\n    print decrypt(deserialize_compact(jwt), {'k':key},\n        validate_claims=False)\n\n\ndef _cli():\n    import inspect\n    import sys\n\n    from argparse import ArgumentParser\n    from copy import copy\n\n    parser = ArgumentParser()\n    subparsers = parser.add_subparsers(dest='subparser_name')\n\n    commands = {\n        'decrypt': cli_decrypt,\n    }\n    for k, fn in commands.items():\n        p = subparsers.add_parser(k)\n        for arg in inspect.getargspec(fn).args:\n            p.add_argument(arg)\n\n    args = parser.parse_args()\n    handler = commands[args.subparser_name]\n    handler_args = [getattr(args, k) for k in inspect.getargspec(\n        handler).args]\n    handler(*handler_args)\n&quot;},&quot;codebaseEnabled&quot;:true,&quot;ragFiles&quot;:[{&quot;path&quot;:&quot;core/security.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\security.py&quot;,&quot;sources&quot;:[&quot;keyword_search&quot;]},{&quot;path&quot;:&quot;core\\config.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\config.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;__init__.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\__init__.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\database.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\database.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;agents\\job_creator_agent.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\agents\\job_creator_agent.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;main.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;pyproject.toml&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\pyproject.toml&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;README.md&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\README.md&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;.gitignore&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.gitignore&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;alembic\\alembic.ini&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\alembic\\alembic.ini&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;services\\auth_service.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\services\\auth_service.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\security.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\security.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;models/models.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\models\\models.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;core/security.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\security.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;models/organization.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\models\\organization.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;schemas/auth.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\schemas\\auth.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;schemas/schemas.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\schemas\\schemas.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;services/auth_service.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\services\\auth_service.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;__init__.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\__init__.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;main.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;.env&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.env&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;.venv/Lib/site-packages/jose.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]}],&quot;rerankedFiles&quot;:[{&quot;path&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;,&quot;fsPath&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;}],&quot;usedFilePaths&quot;:[{&quot;path&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;],&quot;content&quot;:&quot;import logging\nlogger = logging.getLogger(__name__)\n\ntry:\n    from cjson import encode as json_encode, decode as json_decode\nexcept ImportError:  # pragma: nocover\n    logger.warn('cjson not found, falling back to stdlib json')\n    from json import loads as json_decode, dumps as json_encode\n\nimport zlib\nimport datetime\n\nfrom base64 import urlsafe_b64encode, urlsafe_b64decode\nfrom collections import namedtuple\nfrom copy import deepcopy\nfrom time import time\nfrom struct import pack\n\nfrom Crypto.Hash import HMAC, SHA256, SHA384, SHA512\nfrom Crypto.Cipher import PKCS1_OAEP, AES\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Random import get_random_bytes\nfrom Crypto.Signature import PKCS1_v1_5 as PKCS1_v1_5_SIG\n\n\n__all__ = ['encrypt', 'decrypt', 'sign', 'verify']\n\n\n# XXX: The attribute order is IMPORTANT in the following namedtuple\n# definitions. DO NOT change them, unless you really know what you're doing.\n\nJWE = namedtuple('JWE',\n    'header '\n    'cek '\n    'iv '\n    'ciphertext '\n    'tag ')\n\nJWS = namedtuple('JWS',\n        'header '\n        'payload '\n        'signature ')\n\nJWT = namedtuple('JWT',\n        'header '\n        'claims ')\n\n\nCLAIM_ISSUER = 'iss'\nCLAIM_SUBJECT = 'sub'\nCLAIM_AUDIENCE = 'aud'\nCLAIM_EXPIRATION_TIME = 'exp'\nCLAIM_NOT_BEFORE = 'nbf'\nCLAIM_ISSUED_AT = 'iat'\nCLAIM_JWT_ID = 'jti'\n\n# these are temporary to allow graceful deprecation of legacy encrypted tokens.\n# these will be removed in v1.0\n_TEMP_VER_KEY = '__v'\n_TEMP_VER = 2\n\n\nclass Error(Exception):\n    \&quot;\&quot;\&quot; The base error type raised by jose\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass Expired(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation if a JWT has expired\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass NotYetValid(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation is a JWT is not yet valid\n    \&quot;\&quot;\&quot;\n    pass\n\n\ndef serialize_compact(jwt):\n    \&quot;\&quot;\&quot; Compact serialization of a :class:`~jose.JWE` or :class:`~jose.JWS`\n\n    :rtype: str\n    :returns: A string, representing the compact serialization of a\n              :class:`~jose.JWE` or :class:`~jose.JWS`.\n    \&quot;\&quot;\&quot;\n    return '.'.join(jwt)\n\n\ndef deserialize_compact(jwt):\n    \&quot;\&quot;\&quot; Deserialization of a compact representation of a :class:`~jwt.JWE`\n\n    :param jwt: The serialized JWT to deserialize.\n    :rtype: :class:`~jose.JWT`.\n    :raises: :class:`~jose.Error` if the JWT is malformed\n    \&quot;\&quot;\&quot;\n    parts = jwt.split('.')\n\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-encryption-23#section-9\n    if len(parts) == 3:\n        token_type = JWS\n    elif len(parts) == 5:\n        token_type = JWE\n    else:\n        raise Error('Malformed JWT')\n\n    return token_type(*parts)\n\n\ndef encrypt(claims, jwk, adata='', add_header=None, alg='RSA-OAEP',\n        enc='A128CBC-HS256', rng=get_random_bytes, compression=None):\n    \&quot;\&quot;\&quot; Encrypts the given claims and produces a :class:`~jose.JWE`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWE`.\n    :param jwk: A `dict` representing the JWK to be used for encryption of\n                the CEK. This parameter is algorithm-specific.\n    :param adata: Arbitrary string data to add to the authentication\n                  (i.e. HMAC). The same data must be provided during\n                  decryption.\n    :param add_header: Additional items to be added to the header. Additional\n                       headers *will* be authenticated.\n    :param alg: The algorithm to use for CEK encryption\n    :param enc: The algorithm to use for claims encryption\n    :param rng: Random number generator. A string of random bytes is expected\n                as output.\n    :param compression: The compression algorithm to use. Currently supports\n                `'DEF'`.\n    :rtype: :class:`~jose.JWE`\n    :raises: :class:`~jose.Error` if there is an error producing the JWE\n    \&quot;\&quot;\&quot;\n    # copy so the injected claim doesn't mutate the input claims\n    # this is a temporary hack to allow for graceful deprecation of tokens,\n    # ensuring that the library can still handle decrypting tokens issued\n    # before the implementation of the fix\n    claims = deepcopy(claims)\n    assert _TEMP_VER_KEY not in claims\n    claims[_TEMP_VER_KEY] = _TEMP_VER\n\n    header = dict((add_header or {}).items() + [\n        ('enc', enc), ('alg', alg)])\n\n    # promote the temp key to the header\n    assert _TEMP_VER_KEY not in header\n    header[_TEMP_VER_KEY] = claims[_TEMP_VER_KEY]\n\n    plaintext = json_encode(claims)\n\n    # compress (if required)\n    if compression is not None:\n        header['zip'] = compression\n        try:\n            (compress, _) = COMPRESSION[compression]\n        except KeyError:\n            raise Error(\n                'Unsupported compression algorithm: {}'.format(compression))\n        plaintext = compress(plaintext)\n\n    # body encryption/hash\n    ((cipher, _), key_size), ((hash_fn, _), hash_mod) = JWA[enc]\n    iv = rng(AES.block_size)\n    encryption_key = rng(hash_mod.digest_size)\n\n    ciphertext = cipher(plaintext, encryption_key[-hash_mod.digest_size/2:], iv)\n    hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata),\n            encryption_key[:-hash_mod.digest_size/2], hash_mod)\n\n    # cek encryption\n    (cipher, _), _ = JWA[alg]\n    encryption_key_ciphertext = cipher(encryption_key, jwk)\n\n    return JWE(*map(b64encode_url,\n            (json_encode(header),\n            encryption_key_ciphertext,\n            iv,\n            ciphertext,\n            auth_tag(hash))))\n\n\ndef decrypt(jwe, jwk, adata='', validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Decrypts a deserialized :class:`~jose.JWE`\n\n    :param jwe: An instance of :class:`~jose.JWE`\n    :param jwk: A `dict` representing the JWK required to decrypt the content\n                of the :class:`~jose.JWE`.\n    :param adata: Arbitrary string data used during encryption for additional\n                  authentication.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, encryption_key_ciphertext, iv, ciphertext, tag = map(\n        b64decode_url, jwe)\n    header = json_decode(header)\n\n    # decrypt cek\n    (_, decipher), _ = JWA[header['alg']]\n    encryption_key = decipher(encryption_key_ciphertext, jwk)\n\n    # decrypt body\n    ((_, decipher), _), ((hash_fn, _), mod) = JWA[header['enc']]\n\n    version = header.get(_TEMP_VER_KEY)\n    if version:\n        plaintext = decipher(ciphertext, encryption_key[-mod.digest_size/2:], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n                encryption_key[:-mod.digest_size/2], mod=mod)\n    else:\n        plaintext = decipher(ciphertext, encryption_key[:-mod.digest_size], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n            encryption_key[-mod.digest_size:], mod=mod)\n\n    if not const_compare(auth_tag(hash), tag):\n        raise Error('Mismatched authentication tags')\n\n    if 'zip' in header:\n        try:\n            (_, decompress) = COMPRESSION[header['zip']]\n        except KeyError:\n            raise Error('Unsupported compression algorithm: {}'.format(\n                header['zip']))\n\n        plaintext = decompress(plaintext)\n\n    claims = json_decode(plaintext)\n    try:\n        del claims[_TEMP_VER_KEY]\n    except KeyError:\n        # expected when decrypting legacy tokens\n        pass\n\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef sign(claims, jwk, add_header=None, alg='HS256'):\n    \&quot;\&quot;\&quot; Signs the given claims and produces a :class:`~jose.JWS`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWS`.\n    :param jwk: A `dict` representing the JWK to be used for signing of the\n                :class:`~jose.JWS`. This parameter is algorithm-specific.\n    :parameter add_header: Additional items to be added to the header.\n                           Additional headers *will* be authenticated.\n    :parameter alg: The algorithm to use to produce the signature.\n    :rtype: :class:`~jose.JWS`\n    \&quot;\&quot;\&quot;\n    (hash_fn, _), mod = JWA[alg]\n\n    header = dict((add_header or {}).items() + [('alg', alg)])\n    header, payload = map(b64encode_url, map(json_encode, (header, claims)))\n\n    sig = b64encode_url(hash_fn(_jws_hash_str(header, payload), jwk['k'],\n        mod=mod))\n\n    return JWS(header, payload, sig)\n\n\ndef verify(jws, jwk, alg, validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Verifies the given :class:`~jose.JWS`\n\n    :param jws: The :class:`~jose.JWS` to be verified.\n    :param jwk: A `dict` representing the JWK to use for verification. This\n                parameter is algorithm-specific.\n    :param alg: The algorithm to verify the signature with.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, payload, sig = map(b64decode_url, jws)\n    header = json_decode(header)\n    if alg != header['alg']:\n        raise Error('Invalid algorithm')\n\n    (_, verify_fn), mod = JWA[header['alg']]\n\n    if not verify_fn(_jws_hash_str(jws.header, jws.payload),\n            jwk['k'], sig, mod=mod):\n        raise Error('Mismatched signatures')\n\n    claims = json_decode(b64decode_url(jws.payload))\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef b64decode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    istr = encode_safe(istr)\n    try:\n        return urlsafe_b64decode(istr + '=' * (4 - (len(istr) % 4)))\n    except TypeError as e:\n        raise Error('Unable to decode base64: %s' % (e))\n\n\ndef b64encode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    return urlsafe_b64encode(encode_safe(istr)).rstrip('=')\n\n\ndef encode_safe(istr, encoding='utf8'):\n    try:\n        return istr.encode(encoding)\n    except UnicodeDecodeError:\n        # this will fail if istr is already encoded\n        pass\n    return istr\n\n\ndef auth_tag(hmac):\n    # http://tools.ietf.org/html/\n    # draft-ietf-oauth-json-web-token-19#section-4.1.4\n    return hmac[:len(hmac) // 2]\n\n\ndef pad_pkcs7(s):\n    sz = AES.block_size - (len(s) % AES.block_size)\n    return s + (chr(sz) * sz)\n\n\ndef unpad_pkcs7(s):\n    return s[:-ord(s[-1])]\n\n\ndef encrypt_oaep(plaintext, jwk):\n    return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).encrypt(plaintext)\n\n\ndef decrypt_oaep(ciphertext, jwk):\n    try:\n        return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).decrypt(ciphertext)\n    except ValueError as e:\n        raise Error(e.args[0])\n\n\ndef hmac_sign(s, key, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n    return hmac.digest()\n\n\ndef hmac_verify(s, key, sig, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n\n    if not const_compare(hmac.digest(), sig):\n        return False\n\n    return True\n\n\ndef rsa_sign(s, key, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).sign(hash)\n\n\ndef rsa_verify(s, key, sig, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).verify(hash, sig)\n\n\ndef encrypt_aescbc(plaintext, key, iv):\n    plaintext = pad_pkcs7(plaintext)\n    return AES.new(key, AES.MODE_CBC, iv).encrypt(plaintext)\n\n\ndef decrypt_aescbc(ciphertext, key, iv):\n    return unpad_pkcs7(AES.new(key, AES.MODE_CBC, iv).decrypt(ciphertext))\n\n\ndef const_compare(stra, strb):\n    if len(stra) != len(strb):\n        return False\n\n    res = 0\n    for a, b in zip(stra, strb):\n        res |= ord(a) ^ ord(b)\n    return res == 0\n\n\nclass _JWA(object):\n    \&quot;\&quot;\&quot; Represents the implemented algorithms\n\n    A big TODO list can be found here:\n    http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-24\n    \&quot;\&quot;\&quot;\n    _impl = {\n        'HS256': ((hmac_sign, hmac_verify), SHA256),\n        'HS384': ((hmac_sign, hmac_verify), SHA384),\n        'HS512': ((hmac_sign, hmac_verify), SHA512),\n        'RS256': ((rsa_sign, rsa_verify), SHA256),\n        'RS384': ((rsa_sign, rsa_verify), SHA384),\n        'RS512': ((rsa_sign, rsa_verify), SHA512),\n        'RSA-OAEP': ((encrypt_oaep, decrypt_oaep), 2048),\n\n        'A128CBC': ((encrypt_aescbc, decrypt_aescbc), 128),\n        'A192CBC': ((encrypt_aescbc, decrypt_aescbc), 192),\n        'A256CBC': ((encrypt_aescbc, decrypt_aescbc), 256),\n    }\n\n    def __getitem__(self, key):\n        \&quot;\&quot;\&quot; Derive implementation(s) from key\n        \&quot;\&quot;\&quot;\n        if key in self._impl:\n            return self._impl[key]\n\n        enc, hash = self._compound_from_key(key)\n        return self._impl[enc], self._impl[hash]\n\n    def _compound_from_key(self, key):\n        try:\n            enc, hash = key.split('+')\n            return enc, hash\n        except ValueError:\n            pass\n\n        try:\n            enc, hash = key.split('-')\n            return enc, hash\n        except ValueError:\n            pass\n\n        raise Error('Unsupported algorithm: {}'.format(key))\n\n\nJWA = _JWA()\n\n\nCOMPRESSION = {\n    'DEF': (zlib.compress, zlib.decompress),\n}\n\n\ndef _format_timestamp(ts):\n    dt = datetime.datetime.utcfromtimestamp(ts)\n    return dt.isoformat() + 'Z'\n\n\ndef _check_expiration_time(now, expiration_time):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if now &gt;= expiration_time:\n        raise Expired('Token expired at {}'.format(\n            _format_timestamp(expiration_time))\n        )\n\n\ndef _check_not_before(now, not_before):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if not_before &gt; now:\n        raise NotYetValid('Token not valid until {}'.format(\n            _format_timestamp(not_before))\n        )\n\n\ndef _validate(claims, validate_claims, expiry_seconds):\n    \&quot;\&quot;\&quot; Validate expiry related claims.\n\n    If validate_claims is False, do nothing.\n\n    Otherwise, validate the exp and nbf claims if they are present, and\n    validate the iat claim if expiry_seconds is provided.\n    \&quot;\&quot;\&quot;\n    if not validate_claims:\n        return\n\n    now = time()\n\n    # TODO: implement support for clock skew\n\n    # The exp (expiration time) claim identifies the expiration time on or\n    # after which the JWT MUST NOT be accepted for processing. The\n    # processing of the exp claim requires that the current date/time MUST\n    # be before the expiration date/time listed in the exp claim.\n    try:\n        expiration_time = claims[CLAIM_EXPIRATION_TIME]\n    except KeyError:\n        pass\n    else:\n        _check_expiration_time(now, expiration_time)\n\n    # The iat (issued at) claim identifies the time at which the JWT was\n    # issued. This claim can be used to determine the age of the JWT.\n    # If expiry_seconds is provided, and the iat claims is present,\n    # determine the age of the token and check if it has expired.\n    try:\n        issued_at = claims[CLAIM_ISSUED_AT]\n    except KeyError:\n        pass\n    else:\n        if expiry_seconds is not None:\n            _check_expiration_time(now, issued_at + expiry_seconds)\n\n    # The nbf (not before) claim identifies the time before which the JWT\n    # MUST NOT be accepted for processing. The processing of the nbf claim\n    # requires that the current date/time MUST be after or equal to the\n    # not-before date/time listed in the nbf claim.\n    try:\n        not_before = claims[CLAIM_NOT_BEFORE]\n    except KeyError:\n        pass\n    else:\n        _check_not_before(now, not_before)\n\n\ndef _jwe_hash_str(ciphertext, iv, adata='', version=_TEMP_VER):\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-algorithms-24#section-5.2.2.1\n    # Both tokens without version and with version 1 should be ignored in\n    # the future as they use incorrect hashing. The version parameter\n    # should also be removed.\n    if not version:\n        return '.'.join((adata, iv, ciphertext, str(len(adata))))\n    elif version == 1:\n        return '.'.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n    return ''.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n\n\ndef _jws_hash_str(header, claims):\n    return '.'.join((header, claims))\n\n\ndef cli_decrypt(jwt, key):\n    print decrypt(deserialize_compact(jwt), {'k':key},\n        validate_claims=False)\n\n\ndef _cli():\n    import inspect\n    import sys\n\n    from argparse import ArgumentParser\n    from copy import copy\n\n    parser = ArgumentParser()\n    subparsers = parser.add_subparsers(dest='subparser_name')\n\n    commands = {\n        'decrypt': cli_decrypt,\n    }\n    for k, fn in commands.items():\n        p = subparsers.add_parser(k)\n        for arg in inspect.getargspec(fn).args:\n            p.add_argument(arg)\n\n    args = parser.parse_args()\n    handler = commands[args.subparser_name]\n    handler_args = [getattr(args, k) for k in inspect.getargspec(\n        handler).args]\n    handler(*handler_args)\n&quot;}]},&quot;createdAt&quot;:1751746546789,&quot;isInternal&quot;:false},{&quot;id&quot;:&quot;bc817755-0868-4def-97c1-a538fcccd0fc&quot;,&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;and this :&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;  File \&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py\&quot;, line 19, in &lt;module&gt;&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;    from Crypto.Hash import HMAC, SHA256, SHA384, SHA512&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;ModuleNotFoundError: No module named 'Crypto'&quot;}],&quot;context&quot;:{&quot;currentFile&quot;:{&quot;path&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;],&quot;content&quot;:&quot;import logging\nlogger = logging.getLogger(__name__)\n\ntry:\n    from cjson import encode as json_encode, decode as json_decode\nexcept ImportError:  # pragma: nocover\n    logger.warn('cjson not found, falling back to stdlib json')\n    from json import loads as json_decode, dumps as json_encode\n\nimport zlib\nimport datetime\n\nfrom base64 import urlsafe_b64encode, urlsafe_b64decode\nfrom collections import namedtuple\nfrom copy import deepcopy\nfrom time import time\nfrom struct import pack\n\nfrom Crypto.Hash import HMAC, SHA256, SHA384, SHA512\nfrom Crypto.Cipher import PKCS1_OAEP, AES\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Random import get_random_bytes\nfrom Crypto.Signature import PKCS1_v1_5 as PKCS1_v1_5_SIG\n\n\n__all__ = ['encrypt', 'decrypt', 'sign', 'verify']\n\n\n# XXX: The attribute order is IMPORTANT in the following namedtuple\n# definitions. DO NOT change them, unless you really know what you're doing.\n\nJWE = namedtuple('JWE',\n    'header '\n    'cek '\n    'iv '\n    'ciphertext '\n    'tag ')\n\nJWS = namedtuple('JWS',\n        'header '\n        'payload '\n        'signature ')\n\nJWT = namedtuple('JWT',\n        'header '\n        'claims ')\n\n\nCLAIM_ISSUER = 'iss'\nCLAIM_SUBJECT = 'sub'\nCLAIM_AUDIENCE = 'aud'\nCLAIM_EXPIRATION_TIME = 'exp'\nCLAIM_NOT_BEFORE = 'nbf'\nCLAIM_ISSUED_AT = 'iat'\nCLAIM_JWT_ID = 'jti'\n\n# these are temporary to allow graceful deprecation of legacy encrypted tokens.\n# these will be removed in v1.0\n_TEMP_VER_KEY = '__v'\n_TEMP_VER = 2\n\n\nclass Error(Exception):\n    \&quot;\&quot;\&quot; The base error type raised by jose\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass Expired(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation if a JWT has expired\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass NotYetValid(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation is a JWT is not yet valid\n    \&quot;\&quot;\&quot;\n    pass\n\n\ndef serialize_compact(jwt):\n    \&quot;\&quot;\&quot; Compact serialization of a :class:`~jose.JWE` or :class:`~jose.JWS`\n\n    :rtype: str\n    :returns: A string, representing the compact serialization of a\n              :class:`~jose.JWE` or :class:`~jose.JWS`.\n    \&quot;\&quot;\&quot;\n    return '.'.join(jwt)\n\n\ndef deserialize_compact(jwt):\n    \&quot;\&quot;\&quot; Deserialization of a compact representation of a :class:`~jwt.JWE`\n\n    :param jwt: The serialized JWT to deserialize.\n    :rtype: :class:`~jose.JWT`.\n    :raises: :class:`~jose.Error` if the JWT is malformed\n    \&quot;\&quot;\&quot;\n    parts = jwt.split('.')\n\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-encryption-23#section-9\n    if len(parts) == 3:\n        token_type = JWS\n    elif len(parts) == 5:\n        token_type = JWE\n    else:\n        raise Error('Malformed JWT')\n\n    return token_type(*parts)\n\n\ndef encrypt(claims, jwk, adata='', add_header=None, alg='RSA-OAEP',\n        enc='A128CBC-HS256', rng=get_random_bytes, compression=None):\n    \&quot;\&quot;\&quot; Encrypts the given claims and produces a :class:`~jose.JWE`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWE`.\n    :param jwk: A `dict` representing the JWK to be used for encryption of\n                the CEK. This parameter is algorithm-specific.\n    :param adata: Arbitrary string data to add to the authentication\n                  (i.e. HMAC). The same data must be provided during\n                  decryption.\n    :param add_header: Additional items to be added to the header. Additional\n                       headers *will* be authenticated.\n    :param alg: The algorithm to use for CEK encryption\n    :param enc: The algorithm to use for claims encryption\n    :param rng: Random number generator. A string of random bytes is expected\n                as output.\n    :param compression: The compression algorithm to use. Currently supports\n                `'DEF'`.\n    :rtype: :class:`~jose.JWE`\n    :raises: :class:`~jose.Error` if there is an error producing the JWE\n    \&quot;\&quot;\&quot;\n    # copy so the injected claim doesn't mutate the input claims\n    # this is a temporary hack to allow for graceful deprecation of tokens,\n    # ensuring that the library can still handle decrypting tokens issued\n    # before the implementation of the fix\n    claims = deepcopy(claims)\n    assert _TEMP_VER_KEY not in claims\n    claims[_TEMP_VER_KEY] = _TEMP_VER\n\n    header = dict((add_header or {}).items() + [\n        ('enc', enc), ('alg', alg)])\n\n    # promote the temp key to the header\n    assert _TEMP_VER_KEY not in header\n    header[_TEMP_VER_KEY] = claims[_TEMP_VER_KEY]\n\n    plaintext = json_encode(claims)\n\n    # compress (if required)\n    if compression is not None:\n        header['zip'] = compression\n        try:\n            (compress, _) = COMPRESSION[compression]\n        except KeyError:\n            raise Error(\n                'Unsupported compression algorithm: {}'.format(compression))\n        plaintext = compress(plaintext)\n\n    # body encryption/hash\n    ((cipher, _), key_size), ((hash_fn, _), hash_mod) = JWA[enc]\n    iv = rng(AES.block_size)\n    encryption_key = rng(hash_mod.digest_size)\n\n    ciphertext = cipher(plaintext, encryption_key[-hash_mod.digest_size/2:], iv)\n    hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata),\n            encryption_key[:-hash_mod.digest_size/2], hash_mod)\n\n    # cek encryption\n    (cipher, _), _ = JWA[alg]\n    encryption_key_ciphertext = cipher(encryption_key, jwk)\n\n    return JWE(*map(b64encode_url,\n            (json_encode(header),\n            encryption_key_ciphertext,\n            iv,\n            ciphertext,\n            auth_tag(hash))))\n\n\ndef decrypt(jwe, jwk, adata='', validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Decrypts a deserialized :class:`~jose.JWE`\n\n    :param jwe: An instance of :class:`~jose.JWE`\n    :param jwk: A `dict` representing the JWK required to decrypt the content\n                of the :class:`~jose.JWE`.\n    :param adata: Arbitrary string data used during encryption for additional\n                  authentication.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, encryption_key_ciphertext, iv, ciphertext, tag = map(\n        b64decode_url, jwe)\n    header = json_decode(header)\n\n    # decrypt cek\n    (_, decipher), _ = JWA[header['alg']]\n    encryption_key = decipher(encryption_key_ciphertext, jwk)\n\n    # decrypt body\n    ((_, decipher), _), ((hash_fn, _), mod) = JWA[header['enc']]\n\n    version = header.get(_TEMP_VER_KEY)\n    if version:\n        plaintext = decipher(ciphertext, encryption_key[-mod.digest_size/2:], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n                encryption_key[:-mod.digest_size/2], mod=mod)\n    else:\n        plaintext = decipher(ciphertext, encryption_key[:-mod.digest_size], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n            encryption_key[-mod.digest_size:], mod=mod)\n\n    if not const_compare(auth_tag(hash), tag):\n        raise Error('Mismatched authentication tags')\n\n    if 'zip' in header:\n        try:\n            (_, decompress) = COMPRESSION[header['zip']]\n        except KeyError:\n            raise Error('Unsupported compression algorithm: {}'.format(\n                header['zip']))\n\n        plaintext = decompress(plaintext)\n\n    claims = json_decode(plaintext)\n    try:\n        del claims[_TEMP_VER_KEY]\n    except KeyError:\n        # expected when decrypting legacy tokens\n        pass\n\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef sign(claims, jwk, add_header=None, alg='HS256'):\n    \&quot;\&quot;\&quot; Signs the given claims and produces a :class:`~jose.JWS`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWS`.\n    :param jwk: A `dict` representing the JWK to be used for signing of the\n                :class:`~jose.JWS`. This parameter is algorithm-specific.\n    :parameter add_header: Additional items to be added to the header.\n                           Additional headers *will* be authenticated.\n    :parameter alg: The algorithm to use to produce the signature.\n    :rtype: :class:`~jose.JWS`\n    \&quot;\&quot;\&quot;\n    (hash_fn, _), mod = JWA[alg]\n\n    header = dict((add_header or {}).items() + [('alg', alg)])\n    header, payload = map(b64encode_url, map(json_encode, (header, claims)))\n\n    sig = b64encode_url(hash_fn(_jws_hash_str(header, payload), jwk['k'],\n        mod=mod))\n\n    return JWS(header, payload, sig)\n\n\ndef verify(jws, jwk, alg, validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Verifies the given :class:`~jose.JWS`\n\n    :param jws: The :class:`~jose.JWS` to be verified.\n    :param jwk: A `dict` representing the JWK to use for verification. This\n                parameter is algorithm-specific.\n    :param alg: The algorithm to verify the signature with.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, payload, sig = map(b64decode_url, jws)\n    header = json_decode(header)\n    if alg != header['alg']:\n        raise Error('Invalid algorithm')\n\n    (_, verify_fn), mod = JWA[header['alg']]\n\n    if not verify_fn(_jws_hash_str(jws.header, jws.payload),\n            jwk['k'], sig, mod=mod):\n        raise Error('Mismatched signatures')\n\n    claims = json_decode(b64decode_url(jws.payload))\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef b64decode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    istr = encode_safe(istr)\n    try:\n        return urlsafe_b64decode(istr + '=' * (4 - (len(istr) % 4)))\n    except TypeError as e:\n        raise Error('Unable to decode base64: %s' % (e))\n\n\ndef b64encode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    return urlsafe_b64encode(encode_safe(istr)).rstrip('=')\n\n\ndef encode_safe(istr, encoding='utf8'):\n    try:\n        return istr.encode(encoding)\n    except UnicodeDecodeError:\n        # this will fail if istr is already encoded\n        pass\n    return istr\n\n\ndef auth_tag(hmac):\n    # http://tools.ietf.org/html/\n    # draft-ietf-oauth-json-web-token-19#section-4.1.4\n    return hmac[:len(hmac) // 2]\n\n\ndef pad_pkcs7(s):\n    sz = AES.block_size - (len(s) % AES.block_size)\n    return s + (chr(sz) * sz)\n\n\ndef unpad_pkcs7(s):\n    return s[:-ord(s[-1])]\n\n\ndef encrypt_oaep(plaintext, jwk):\n    return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).encrypt(plaintext)\n\n\ndef decrypt_oaep(ciphertext, jwk):\n    try:\n        return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).decrypt(ciphertext)\n    except ValueError as e:\n        raise Error(e.args[0])\n\n\ndef hmac_sign(s, key, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n    return hmac.digest()\n\n\ndef hmac_verify(s, key, sig, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n\n    if not const_compare(hmac.digest(), sig):\n        return False\n\n    return True\n\n\ndef rsa_sign(s, key, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).sign(hash)\n\n\ndef rsa_verify(s, key, sig, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).verify(hash, sig)\n\n\ndef encrypt_aescbc(plaintext, key, iv):\n    plaintext = pad_pkcs7(plaintext)\n    return AES.new(key, AES.MODE_CBC, iv).encrypt(plaintext)\n\n\ndef decrypt_aescbc(ciphertext, key, iv):\n    return unpad_pkcs7(AES.new(key, AES.MODE_CBC, iv).decrypt(ciphertext))\n\n\ndef const_compare(stra, strb):\n    if len(stra) != len(strb):\n        return False\n\n    res = 0\n    for a, b in zip(stra, strb):\n        res |= ord(a) ^ ord(b)\n    return res == 0\n\n\nclass _JWA(object):\n    \&quot;\&quot;\&quot; Represents the implemented algorithms\n\n    A big TODO list can be found here:\n    http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-24\n    \&quot;\&quot;\&quot;\n    _impl = {\n        'HS256': ((hmac_sign, hmac_verify), SHA256),\n        'HS384': ((hmac_sign, hmac_verify), SHA384),\n        'HS512': ((hmac_sign, hmac_verify), SHA512),\n        'RS256': ((rsa_sign, rsa_verify), SHA256),\n        'RS384': ((rsa_sign, rsa_verify), SHA384),\n        'RS512': ((rsa_sign, rsa_verify), SHA512),\n        'RSA-OAEP': ((encrypt_oaep, decrypt_oaep), 2048),\n\n        'A128CBC': ((encrypt_aescbc, decrypt_aescbc), 128),\n        'A192CBC': ((encrypt_aescbc, decrypt_aescbc), 192),\n        'A256CBC': ((encrypt_aescbc, decrypt_aescbc), 256),\n    }\n\n    def __getitem__(self, key):\n        \&quot;\&quot;\&quot; Derive implementation(s) from key\n        \&quot;\&quot;\&quot;\n        if key in self._impl:\n            return self._impl[key]\n\n        enc, hash = self._compound_from_key(key)\n        return self._impl[enc], self._impl[hash]\n\n    def _compound_from_key(self, key):\n        try:\n            enc, hash = key.split('+')\n            return enc, hash\n        except ValueError:\n            pass\n\n        try:\n            enc, hash = key.split('-')\n            return enc, hash\n        except ValueError:\n            pass\n\n        raise Error('Unsupported algorithm: {}'.format(key))\n\n\nJWA = _JWA()\n\n\nCOMPRESSION = {\n    'DEF': (zlib.compress, zlib.decompress),\n}\n\n\ndef _format_timestamp(ts):\n    dt = datetime.datetime.utcfromtimestamp(ts)\n    return dt.isoformat() + 'Z'\n\n\ndef _check_expiration_time(now, expiration_time):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if now &gt;= expiration_time:\n        raise Expired('Token expired at {}'.format(\n            _format_timestamp(expiration_time))\n        )\n\n\ndef _check_not_before(now, not_before):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if not_before &gt; now:\n        raise NotYetValid('Token not valid until {}'.format(\n            _format_timestamp(not_before))\n        )\n\n\ndef _validate(claims, validate_claims, expiry_seconds):\n    \&quot;\&quot;\&quot; Validate expiry related claims.\n\n    If validate_claims is False, do nothing.\n\n    Otherwise, validate the exp and nbf claims if they are present, and\n    validate the iat claim if expiry_seconds is provided.\n    \&quot;\&quot;\&quot;\n    if not validate_claims:\n        return\n\n    now = time()\n\n    # TODO: implement support for clock skew\n\n    # The exp (expiration time) claim identifies the expiration time on or\n    # after which the JWT MUST NOT be accepted for processing. The\n    # processing of the exp claim requires that the current date/time MUST\n    # be before the expiration date/time listed in the exp claim.\n    try:\n        expiration_time = claims[CLAIM_EXPIRATION_TIME]\n    except KeyError:\n        pass\n    else:\n        _check_expiration_time(now, expiration_time)\n\n    # The iat (issued at) claim identifies the time at which the JWT was\n    # issued. This claim can be used to determine the age of the JWT.\n    # If expiry_seconds is provided, and the iat claims is present,\n    # determine the age of the token and check if it has expired.\n    try:\n        issued_at = claims[CLAIM_ISSUED_AT]\n    except KeyError:\n        pass\n    else:\n        if expiry_seconds is not None:\n            _check_expiration_time(now, issued_at + expiry_seconds)\n\n    # The nbf (not before) claim identifies the time before which the JWT\n    # MUST NOT be accepted for processing. The processing of the nbf claim\n    # requires that the current date/time MUST be after or equal to the\n    # not-before date/time listed in the nbf claim.\n    try:\n        not_before = claims[CLAIM_NOT_BEFORE]\n    except KeyError:\n        pass\n    else:\n        _check_not_before(now, not_before)\n\n\ndef _jwe_hash_str(ciphertext, iv, adata='', version=_TEMP_VER):\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-algorithms-24#section-5.2.2.1\n    # Both tokens without version and with version 1 should be ignored in\n    # the future as they use incorrect hashing. The version parameter\n    # should also be removed.\n    if not version:\n        return '.'.join((adata, iv, ciphertext, str(len(adata))))\n    elif version == 1:\n        return '.'.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n    return ''.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n\n\ndef _jws_hash_str(header, claims):\n    return '.'.join((header, claims))\n\n\ndef cli_decrypt(jwt, key):\n    print decrypt(deserialize_compact(jwt), {'k':key},\n        validate_claims=False)\n\n\ndef _cli():\n    import inspect\n    import sys\n\n    from argparse import ArgumentParser\n    from copy import copy\n\n    parser = ArgumentParser()\n    subparsers = parser.add_subparsers(dest='subparser_name')\n\n    commands = {\n        'decrypt': cli_decrypt,\n    }\n    for k, fn in commands.items():\n        p = subparsers.add_parser(k)\n        for arg in inspect.getargspec(fn).args:\n            p.add_argument(arg)\n\n    args = parser.parse_args()\n    handler = commands[args.subparser_name]\n    handler_args = [getattr(args, k) for k in inspect.getargspec(\n        handler).args]\n    handler(*handler_args)\n&quot;},&quot;codebaseEnabled&quot;:true,&quot;ragFiles&quot;:[{&quot;path&quot;:&quot;core/security.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\security.py&quot;,&quot;sources&quot;:[&quot;keyword_search&quot;]},{&quot;path&quot;:&quot;__init__.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\__init__.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\config.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\config.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;agents\\job_creator_agent.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\agents\\job_creator_agent.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;schemas\\auth.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\schemas\\auth.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\database.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\database.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;pyproject.toml&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\pyproject.toml&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;.gitignore&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.gitignore&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;README.md&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\README.md&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;alembic\\alembic.ini&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\alembic\\alembic.ini&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;services\\auth_service.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\services\\auth_service.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\security.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\security.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;api\\routes\\auth.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\api\\routes\\auth.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;models/models.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\models\\models.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;core/security.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\security.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;models/organization.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\models\\organization.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;schemas/auth.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\schemas\\auth.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;schemas/schemas.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\schemas\\schemas.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;services/auth_service.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\services\\auth_service.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;__init__.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\__init__.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;main.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;.env&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.env&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;.venv/Lib/site-packages/jose.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]}],&quot;rerankedFiles&quot;:[{&quot;path&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;,&quot;fsPath&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;},{&quot;path&quot;:&quot;pyproject.toml&quot;,&quot;fsPath&quot;:&quot;pyproject.toml&quot;}],&quot;usedFilePaths&quot;:[{&quot;path&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;],&quot;content&quot;:&quot;import logging\nlogger = logging.getLogger(__name__)\n\ntry:\n    from cjson import encode as json_encode, decode as json_decode\nexcept ImportError:  # pragma: nocover\n    logger.warn('cjson not found, falling back to stdlib json')\n    from json import loads as json_decode, dumps as json_encode\n\nimport zlib\nimport datetime\n\nfrom base64 import urlsafe_b64encode, urlsafe_b64decode\nfrom collections import namedtuple\nfrom copy import deepcopy\nfrom time import time\nfrom struct import pack\n\nfrom Crypto.Hash import HMAC, SHA256, SHA384, SHA512\nfrom Crypto.Cipher import PKCS1_OAEP, AES\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Random import get_random_bytes\nfrom Crypto.Signature import PKCS1_v1_5 as PKCS1_v1_5_SIG\n\n\n__all__ = ['encrypt', 'decrypt', 'sign', 'verify']\n\n\n# XXX: The attribute order is IMPORTANT in the following namedtuple\n# definitions. DO NOT change them, unless you really know what you're doing.\n\nJWE = namedtuple('JWE',\n    'header '\n    'cek '\n    'iv '\n    'ciphertext '\n    'tag ')\n\nJWS = namedtuple('JWS',\n        'header '\n        'payload '\n        'signature ')\n\nJWT = namedtuple('JWT',\n        'header '\n        'claims ')\n\n\nCLAIM_ISSUER = 'iss'\nCLAIM_SUBJECT = 'sub'\nCLAIM_AUDIENCE = 'aud'\nCLAIM_EXPIRATION_TIME = 'exp'\nCLAIM_NOT_BEFORE = 'nbf'\nCLAIM_ISSUED_AT = 'iat'\nCLAIM_JWT_ID = 'jti'\n\n# these are temporary to allow graceful deprecation of legacy encrypted tokens.\n# these will be removed in v1.0\n_TEMP_VER_KEY = '__v'\n_TEMP_VER = 2\n\n\nclass Error(Exception):\n    \&quot;\&quot;\&quot; The base error type raised by jose\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass Expired(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation if a JWT has expired\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass NotYetValid(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation is a JWT is not yet valid\n    \&quot;\&quot;\&quot;\n    pass\n\n\ndef serialize_compact(jwt):\n    \&quot;\&quot;\&quot; Compact serialization of a :class:`~jose.JWE` or :class:`~jose.JWS`\n\n    :rtype: str\n    :returns: A string, representing the compact serialization of a\n              :class:`~jose.JWE` or :class:`~jose.JWS`.\n    \&quot;\&quot;\&quot;\n    return '.'.join(jwt)\n\n\ndef deserialize_compact(jwt):\n    \&quot;\&quot;\&quot; Deserialization of a compact representation of a :class:`~jwt.JWE`\n\n    :param jwt: The serialized JWT to deserialize.\n    :rtype: :class:`~jose.JWT`.\n    :raises: :class:`~jose.Error` if the JWT is malformed\n    \&quot;\&quot;\&quot;\n    parts = jwt.split('.')\n\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-encryption-23#section-9\n    if len(parts) == 3:\n        token_type = JWS\n    elif len(parts) == 5:\n        token_type = JWE\n    else:\n        raise Error('Malformed JWT')\n\n    return token_type(*parts)\n\n\ndef encrypt(claims, jwk, adata='', add_header=None, alg='RSA-OAEP',\n        enc='A128CBC-HS256', rng=get_random_bytes, compression=None):\n    \&quot;\&quot;\&quot; Encrypts the given claims and produces a :class:`~jose.JWE`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWE`.\n    :param jwk: A `dict` representing the JWK to be used for encryption of\n                the CEK. This parameter is algorithm-specific.\n    :param adata: Arbitrary string data to add to the authentication\n                  (i.e. HMAC). The same data must be provided during\n                  decryption.\n    :param add_header: Additional items to be added to the header. Additional\n                       headers *will* be authenticated.\n    :param alg: The algorithm to use for CEK encryption\n    :param enc: The algorithm to use for claims encryption\n    :param rng: Random number generator. A string of random bytes is expected\n                as output.\n    :param compression: The compression algorithm to use. Currently supports\n                `'DEF'`.\n    :rtype: :class:`~jose.JWE`\n    :raises: :class:`~jose.Error` if there is an error producing the JWE\n    \&quot;\&quot;\&quot;\n    # copy so the injected claim doesn't mutate the input claims\n    # this is a temporary hack to allow for graceful deprecation of tokens,\n    # ensuring that the library can still handle decrypting tokens issued\n    # before the implementation of the fix\n    claims = deepcopy(claims)\n    assert _TEMP_VER_KEY not in claims\n    claims[_TEMP_VER_KEY] = _TEMP_VER\n\n    header = dict((add_header or {}).items() + [\n        ('enc', enc), ('alg', alg)])\n\n    # promote the temp key to the header\n    assert _TEMP_VER_KEY not in header\n    header[_TEMP_VER_KEY] = claims[_TEMP_VER_KEY]\n\n    plaintext = json_encode(claims)\n\n    # compress (if required)\n    if compression is not None:\n        header['zip'] = compression\n        try:\n            (compress, _) = COMPRESSION[compression]\n        except KeyError:\n            raise Error(\n                'Unsupported compression algorithm: {}'.format(compression))\n        plaintext = compress(plaintext)\n\n    # body encryption/hash\n    ((cipher, _), key_size), ((hash_fn, _), hash_mod) = JWA[enc]\n    iv = rng(AES.block_size)\n    encryption_key = rng(hash_mod.digest_size)\n\n    ciphertext = cipher(plaintext, encryption_key[-hash_mod.digest_size/2:], iv)\n    hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata),\n            encryption_key[:-hash_mod.digest_size/2], hash_mod)\n\n    # cek encryption\n    (cipher, _), _ = JWA[alg]\n    encryption_key_ciphertext = cipher(encryption_key, jwk)\n\n    return JWE(*map(b64encode_url,\n            (json_encode(header),\n            encryption_key_ciphertext,\n            iv,\n            ciphertext,\n            auth_tag(hash))))\n\n\ndef decrypt(jwe, jwk, adata='', validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Decrypts a deserialized :class:`~jose.JWE`\n\n    :param jwe: An instance of :class:`~jose.JWE`\n    :param jwk: A `dict` representing the JWK required to decrypt the content\n                of the :class:`~jose.JWE`.\n    :param adata: Arbitrary string data used during encryption for additional\n                  authentication.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, encryption_key_ciphertext, iv, ciphertext, tag = map(\n        b64decode_url, jwe)\n    header = json_decode(header)\n\n    # decrypt cek\n    (_, decipher), _ = JWA[header['alg']]\n    encryption_key = decipher(encryption_key_ciphertext, jwk)\n\n    # decrypt body\n    ((_, decipher), _), ((hash_fn, _), mod) = JWA[header['enc']]\n\n    version = header.get(_TEMP_VER_KEY)\n    if version:\n        plaintext = decipher(ciphertext, encryption_key[-mod.digest_size/2:], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n                encryption_key[:-mod.digest_size/2], mod=mod)\n    else:\n        plaintext = decipher(ciphertext, encryption_key[:-mod.digest_size], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n            encryption_key[-mod.digest_size:], mod=mod)\n\n    if not const_compare(auth_tag(hash), tag):\n        raise Error('Mismatched authentication tags')\n\n    if 'zip' in header:\n        try:\n            (_, decompress) = COMPRESSION[header['zip']]\n        except KeyError:\n            raise Error('Unsupported compression algorithm: {}'.format(\n                header['zip']))\n\n        plaintext = decompress(plaintext)\n\n    claims = json_decode(plaintext)\n    try:\n        del claims[_TEMP_VER_KEY]\n    except KeyError:\n        # expected when decrypting legacy tokens\n        pass\n\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef sign(claims, jwk, add_header=None, alg='HS256'):\n    \&quot;\&quot;\&quot; Signs the given claims and produces a :class:`~jose.JWS`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWS`.\n    :param jwk: A `dict` representing the JWK to be used for signing of the\n                :class:`~jose.JWS`. This parameter is algorithm-specific.\n    :parameter add_header: Additional items to be added to the header.\n                           Additional headers *will* be authenticated.\n    :parameter alg: The algorithm to use to produce the signature.\n    :rtype: :class:`~jose.JWS`\n    \&quot;\&quot;\&quot;\n    (hash_fn, _), mod = JWA[alg]\n\n    header = dict((add_header or {}).items() + [('alg', alg)])\n    header, payload = map(b64encode_url, map(json_encode, (header, claims)))\n\n    sig = b64encode_url(hash_fn(_jws_hash_str(header, payload), jwk['k'],\n        mod=mod))\n\n    return JWS(header, payload, sig)\n\n\ndef verify(jws, jwk, alg, validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Verifies the given :class:`~jose.JWS`\n\n    :param jws: The :class:`~jose.JWS` to be verified.\n    :param jwk: A `dict` representing the JWK to use for verification. This\n                parameter is algorithm-specific.\n    :param alg: The algorithm to verify the signature with.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, payload, sig = map(b64decode_url, jws)\n    header = json_decode(header)\n    if alg != header['alg']:\n        raise Error('Invalid algorithm')\n\n    (_, verify_fn), mod = JWA[header['alg']]\n\n    if not verify_fn(_jws_hash_str(jws.header, jws.payload),\n            jwk['k'], sig, mod=mod):\n        raise Error('Mismatched signatures')\n\n    claims = json_decode(b64decode_url(jws.payload))\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef b64decode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    istr = encode_safe(istr)\n    try:\n        return urlsafe_b64decode(istr + '=' * (4 - (len(istr) % 4)))\n    except TypeError as e:\n        raise Error('Unable to decode base64: %s' % (e))\n\n\ndef b64encode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    return urlsafe_b64encode(encode_safe(istr)).rstrip('=')\n\n\ndef encode_safe(istr, encoding='utf8'):\n    try:\n        return istr.encode(encoding)\n    except UnicodeDecodeError:\n        # this will fail if istr is already encoded\n        pass\n    return istr\n\n\ndef auth_tag(hmac):\n    # http://tools.ietf.org/html/\n    # draft-ietf-oauth-json-web-token-19#section-4.1.4\n    return hmac[:len(hmac) // 2]\n\n\ndef pad_pkcs7(s):\n    sz = AES.block_size - (len(s) % AES.block_size)\n    return s + (chr(sz) * sz)\n\n\ndef unpad_pkcs7(s):\n    return s[:-ord(s[-1])]\n\n\ndef encrypt_oaep(plaintext, jwk):\n    return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).encrypt(plaintext)\n\n\ndef decrypt_oaep(ciphertext, jwk):\n    try:\n        return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).decrypt(ciphertext)\n    except ValueError as e:\n        raise Error(e.args[0])\n\n\ndef hmac_sign(s, key, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n    return hmac.digest()\n\n\ndef hmac_verify(s, key, sig, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n\n    if not const_compare(hmac.digest(), sig):\n        return False\n\n    return True\n\n\ndef rsa_sign(s, key, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).sign(hash)\n\n\ndef rsa_verify(s, key, sig, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).verify(hash, sig)\n\n\ndef encrypt_aescbc(plaintext, key, iv):\n    plaintext = pad_pkcs7(plaintext)\n    return AES.new(key, AES.MODE_CBC, iv).encrypt(plaintext)\n\n\ndef decrypt_aescbc(ciphertext, key, iv):\n    return unpad_pkcs7(AES.new(key, AES.MODE_CBC, iv).decrypt(ciphertext))\n\n\ndef const_compare(stra, strb):\n    if len(stra) != len(strb):\n        return False\n\n    res = 0\n    for a, b in zip(stra, strb):\n        res |= ord(a) ^ ord(b)\n    return res == 0\n\n\nclass _JWA(object):\n    \&quot;\&quot;\&quot; Represents the implemented algorithms\n\n    A big TODO list can be found here:\n    http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-24\n    \&quot;\&quot;\&quot;\n    _impl = {\n        'HS256': ((hmac_sign, hmac_verify), SHA256),\n        'HS384': ((hmac_sign, hmac_verify), SHA384),\n        'HS512': ((hmac_sign, hmac_verify), SHA512),\n        'RS256': ((rsa_sign, rsa_verify), SHA256),\n        'RS384': ((rsa_sign, rsa_verify), SHA384),\n        'RS512': ((rsa_sign, rsa_verify), SHA512),\n        'RSA-OAEP': ((encrypt_oaep, decrypt_oaep), 2048),\n\n        'A128CBC': ((encrypt_aescbc, decrypt_aescbc), 128),\n        'A192CBC': ((encrypt_aescbc, decrypt_aescbc), 192),\n        'A256CBC': ((encrypt_aescbc, decrypt_aescbc), 256),\n    }\n\n    def __getitem__(self, key):\n        \&quot;\&quot;\&quot; Derive implementation(s) from key\n        \&quot;\&quot;\&quot;\n        if key in self._impl:\n            return self._impl[key]\n\n        enc, hash = self._compound_from_key(key)\n        return self._impl[enc], self._impl[hash]\n\n    def _compound_from_key(self, key):\n        try:\n            enc, hash = key.split('+')\n            return enc, hash\n        except ValueError:\n            pass\n\n        try:\n            enc, hash = key.split('-')\n            return enc, hash\n        except ValueError:\n            pass\n\n        raise Error('Unsupported algorithm: {}'.format(key))\n\n\nJWA = _JWA()\n\n\nCOMPRESSION = {\n    'DEF': (zlib.compress, zlib.decompress),\n}\n\n\ndef _format_timestamp(ts):\n    dt = datetime.datetime.utcfromtimestamp(ts)\n    return dt.isoformat() + 'Z'\n\n\ndef _check_expiration_time(now, expiration_time):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if now &gt;= expiration_time:\n        raise Expired('Token expired at {}'.format(\n            _format_timestamp(expiration_time))\n        )\n\n\ndef _check_not_before(now, not_before):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if not_before &gt; now:\n        raise NotYetValid('Token not valid until {}'.format(\n            _format_timestamp(not_before))\n        )\n\n\ndef _validate(claims, validate_claims, expiry_seconds):\n    \&quot;\&quot;\&quot; Validate expiry related claims.\n\n    If validate_claims is False, do nothing.\n\n    Otherwise, validate the exp and nbf claims if they are present, and\n    validate the iat claim if expiry_seconds is provided.\n    \&quot;\&quot;\&quot;\n    if not validate_claims:\n        return\n\n    now = time()\n\n    # TODO: implement support for clock skew\n\n    # The exp (expiration time) claim identifies the expiration time on or\n    # after which the JWT MUST NOT be accepted for processing. The\n    # processing of the exp claim requires that the current date/time MUST\n    # be before the expiration date/time listed in the exp claim.\n    try:\n        expiration_time = claims[CLAIM_EXPIRATION_TIME]\n    except KeyError:\n        pass\n    else:\n        _check_expiration_time(now, expiration_time)\n\n    # The iat (issued at) claim identifies the time at which the JWT was\n    # issued. This claim can be used to determine the age of the JWT.\n    # If expiry_seconds is provided, and the iat claims is present,\n    # determine the age of the token and check if it has expired.\n    try:\n        issued_at = claims[CLAIM_ISSUED_AT]\n    except KeyError:\n        pass\n    else:\n        if expiry_seconds is not None:\n            _check_expiration_time(now, issued_at + expiry_seconds)\n\n    # The nbf (not before) claim identifies the time before which the JWT\n    # MUST NOT be accepted for processing. The processing of the nbf claim\n    # requires that the current date/time MUST be after or equal to the\n    # not-before date/time listed in the nbf claim.\n    try:\n        not_before = claims[CLAIM_NOT_BEFORE]\n    except KeyError:\n        pass\n    else:\n        _check_not_before(now, not_before)\n\n\ndef _jwe_hash_str(ciphertext, iv, adata='', version=_TEMP_VER):\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-algorithms-24#section-5.2.2.1\n    # Both tokens without version and with version 1 should be ignored in\n    # the future as they use incorrect hashing. The version parameter\n    # should also be removed.\n    if not version:\n        return '.'.join((adata, iv, ciphertext, str(len(adata))))\n    elif version == 1:\n        return '.'.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n    return ''.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n\n\ndef _jws_hash_str(header, claims):\n    return '.'.join((header, claims))\n\n\ndef cli_decrypt(jwt, key):\n    print decrypt(deserialize_compact(jwt), {'k':key},\n        validate_claims=False)\n\n\ndef _cli():\n    import inspect\n    import sys\n\n    from argparse import ArgumentParser\n    from copy import copy\n\n    parser = ArgumentParser()\n    subparsers = parser.add_subparsers(dest='subparser_name')\n\n    commands = {\n        'decrypt': cli_decrypt,\n    }\n    for k, fn in commands.items():\n        p = subparsers.add_parser(k)\n        for arg in inspect.getargspec(fn).args:\n            p.add_argument(arg)\n\n    args = parser.parse_args()\n    handler = commands[args.subparser_name]\n    handler_args = [getattr(args, k) for k in inspect.getargspec(\n        handler).args]\n    handler(*handler_args)\n&quot;},{&quot;path&quot;:&quot;pyproject.toml&quot;,&quot;fsPath&quot;:&quot;pyproject.toml&quot;}]},&quot;createdAt&quot;:1751746569827,&quot;isInternal&quot;:false,&quot;rawContent&quot;:{&quot;type&quot;:&quot;doc&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;and this :&quot;}]},{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;  File \&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py\&quot;, line 19, in &lt;module&gt;&quot;}]},{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;    from Crypto.Hash import HMAC, SHA256, SHA384, SHA512&quot;}]},{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;ModuleNotFoundError: No module named 'Crypto'&quot;}]}]}},{&quot;id&quot;:&quot;8285e4cd-a76b-4b82-8390-c8f07d06ab51&quot;,&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;The error `ModuleNotFoundError: No module named 'Crypto'` indicates that the `pycryptodome` library, which provides the `Crypto` module, is not installed in your virtual environment. This library is necessary for the cryptographic operations in your `jose.py` file.\n\nTo resolve this issue, you need to install the `pycryptodome` package. You can do this by running the following command in your terminal:\n\n```bash\npip install pycryptodome\n```\n\nMake sure your virtual environment is activated when you run this command. This should resolve the `ModuleNotFoundError` and allow your script to import the necessary modules from `Crypto`.&quot;}],&quot;context&quot;:{&quot;currentFile&quot;:{&quot;path&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;],&quot;content&quot;:&quot;import logging\nlogger = logging.getLogger(__name__)\n\ntry:\n    from cjson import encode as json_encode, decode as json_decode\nexcept ImportError:  # pragma: nocover\n    logger.warn('cjson not found, falling back to stdlib json')\n    from json import loads as json_decode, dumps as json_encode\n\nimport zlib\nimport datetime\n\nfrom base64 import urlsafe_b64encode, urlsafe_b64decode\nfrom collections import namedtuple\nfrom copy import deepcopy\nfrom time import time\nfrom struct import pack\n\nfrom Crypto.Hash import HMAC, SHA256, SHA384, SHA512\nfrom Crypto.Cipher import PKCS1_OAEP, AES\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Random import get_random_bytes\nfrom Crypto.Signature import PKCS1_v1_5 as PKCS1_v1_5_SIG\n\n\n__all__ = ['encrypt', 'decrypt', 'sign', 'verify']\n\n\n# XXX: The attribute order is IMPORTANT in the following namedtuple\n# definitions. DO NOT change them, unless you really know what you're doing.\n\nJWE = namedtuple('JWE',\n    'header '\n    'cek '\n    'iv '\n    'ciphertext '\n    'tag ')\n\nJWS = namedtuple('JWS',\n        'header '\n        'payload '\n        'signature ')\n\nJWT = namedtuple('JWT',\n        'header '\n        'claims ')\n\n\nCLAIM_ISSUER = 'iss'\nCLAIM_SUBJECT = 'sub'\nCLAIM_AUDIENCE = 'aud'\nCLAIM_EXPIRATION_TIME = 'exp'\nCLAIM_NOT_BEFORE = 'nbf'\nCLAIM_ISSUED_AT = 'iat'\nCLAIM_JWT_ID = 'jti'\n\n# these are temporary to allow graceful deprecation of legacy encrypted tokens.\n# these will be removed in v1.0\n_TEMP_VER_KEY = '__v'\n_TEMP_VER = 2\n\n\nclass Error(Exception):\n    \&quot;\&quot;\&quot; The base error type raised by jose\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass Expired(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation if a JWT has expired\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass NotYetValid(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation is a JWT is not yet valid\n    \&quot;\&quot;\&quot;\n    pass\n\n\ndef serialize_compact(jwt):\n    \&quot;\&quot;\&quot; Compact serialization of a :class:`~jose.JWE` or :class:`~jose.JWS`\n\n    :rtype: str\n    :returns: A string, representing the compact serialization of a\n              :class:`~jose.JWE` or :class:`~jose.JWS`.\n    \&quot;\&quot;\&quot;\n    return '.'.join(jwt)\n\n\ndef deserialize_compact(jwt):\n    \&quot;\&quot;\&quot; Deserialization of a compact representation of a :class:`~jwt.JWE`\n\n    :param jwt: The serialized JWT to deserialize.\n    :rtype: :class:`~jose.JWT`.\n    :raises: :class:`~jose.Error` if the JWT is malformed\n    \&quot;\&quot;\&quot;\n    parts = jwt.split('.')\n\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-encryption-23#section-9\n    if len(parts) == 3:\n        token_type = JWS\n    elif len(parts) == 5:\n        token_type = JWE\n    else:\n        raise Error('Malformed JWT')\n\n    return token_type(*parts)\n\n\ndef encrypt(claims, jwk, adata='', add_header=None, alg='RSA-OAEP',\n        enc='A128CBC-HS256', rng=get_random_bytes, compression=None):\n    \&quot;\&quot;\&quot; Encrypts the given claims and produces a :class:`~jose.JWE`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWE`.\n    :param jwk: A `dict` representing the JWK to be used for encryption of\n                the CEK. This parameter is algorithm-specific.\n    :param adata: Arbitrary string data to add to the authentication\n                  (i.e. HMAC). The same data must be provided during\n                  decryption.\n    :param add_header: Additional items to be added to the header. Additional\n                       headers *will* be authenticated.\n    :param alg: The algorithm to use for CEK encryption\n    :param enc: The algorithm to use for claims encryption\n    :param rng: Random number generator. A string of random bytes is expected\n                as output.\n    :param compression: The compression algorithm to use. Currently supports\n                `'DEF'`.\n    :rtype: :class:`~jose.JWE`\n    :raises: :class:`~jose.Error` if there is an error producing the JWE\n    \&quot;\&quot;\&quot;\n    # copy so the injected claim doesn't mutate the input claims\n    # this is a temporary hack to allow for graceful deprecation of tokens,\n    # ensuring that the library can still handle decrypting tokens issued\n    # before the implementation of the fix\n    claims = deepcopy(claims)\n    assert _TEMP_VER_KEY not in claims\n    claims[_TEMP_VER_KEY] = _TEMP_VER\n\n    header = dict((add_header or {}).items() + [\n        ('enc', enc), ('alg', alg)])\n\n    # promote the temp key to the header\n    assert _TEMP_VER_KEY not in header\n    header[_TEMP_VER_KEY] = claims[_TEMP_VER_KEY]\n\n    plaintext = json_encode(claims)\n\n    # compress (if required)\n    if compression is not None:\n        header['zip'] = compression\n        try:\n            (compress, _) = COMPRESSION[compression]\n        except KeyError:\n            raise Error(\n                'Unsupported compression algorithm: {}'.format(compression))\n        plaintext = compress(plaintext)\n\n    # body encryption/hash\n    ((cipher, _), key_size), ((hash_fn, _), hash_mod) = JWA[enc]\n    iv = rng(AES.block_size)\n    encryption_key = rng(hash_mod.digest_size)\n\n    ciphertext = cipher(plaintext, encryption_key[-hash_mod.digest_size/2:], iv)\n    hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata),\n            encryption_key[:-hash_mod.digest_size/2], hash_mod)\n\n    # cek encryption\n    (cipher, _), _ = JWA[alg]\n    encryption_key_ciphertext = cipher(encryption_key, jwk)\n\n    return JWE(*map(b64encode_url,\n            (json_encode(header),\n            encryption_key_ciphertext,\n            iv,\n            ciphertext,\n            auth_tag(hash))))\n\n\ndef decrypt(jwe, jwk, adata='', validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Decrypts a deserialized :class:`~jose.JWE`\n\n    :param jwe: An instance of :class:`~jose.JWE`\n    :param jwk: A `dict` representing the JWK required to decrypt the content\n                of the :class:`~jose.JWE`.\n    :param adata: Arbitrary string data used during encryption for additional\n                  authentication.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, encryption_key_ciphertext, iv, ciphertext, tag = map(\n        b64decode_url, jwe)\n    header = json_decode(header)\n\n    # decrypt cek\n    (_, decipher), _ = JWA[header['alg']]\n    encryption_key = decipher(encryption_key_ciphertext, jwk)\n\n    # decrypt body\n    ((_, decipher), _), ((hash_fn, _), mod) = JWA[header['enc']]\n\n    version = header.get(_TEMP_VER_KEY)\n    if version:\n        plaintext = decipher(ciphertext, encryption_key[-mod.digest_size/2:], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n                encryption_key[:-mod.digest_size/2], mod=mod)\n    else:\n        plaintext = decipher(ciphertext, encryption_key[:-mod.digest_size], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n            encryption_key[-mod.digest_size:], mod=mod)\n\n    if not const_compare(auth_tag(hash), tag):\n        raise Error('Mismatched authentication tags')\n\n    if 'zip' in header:\n        try:\n            (_, decompress) = COMPRESSION[header['zip']]\n        except KeyError:\n            raise Error('Unsupported compression algorithm: {}'.format(\n                header['zip']))\n\n        plaintext = decompress(plaintext)\n\n    claims = json_decode(plaintext)\n    try:\n        del claims[_TEMP_VER_KEY]\n    except KeyError:\n        # expected when decrypting legacy tokens\n        pass\n\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef sign(claims, jwk, add_header=None, alg='HS256'):\n    \&quot;\&quot;\&quot; Signs the given claims and produces a :class:`~jose.JWS`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWS`.\n    :param jwk: A `dict` representing the JWK to be used for signing of the\n                :class:`~jose.JWS`. This parameter is algorithm-specific.\n    :parameter add_header: Additional items to be added to the header.\n                           Additional headers *will* be authenticated.\n    :parameter alg: The algorithm to use to produce the signature.\n    :rtype: :class:`~jose.JWS`\n    \&quot;\&quot;\&quot;\n    (hash_fn, _), mod = JWA[alg]\n\n    header = dict((add_header or {}).items() + [('alg', alg)])\n    header, payload = map(b64encode_url, map(json_encode, (header, claims)))\n\n    sig = b64encode_url(hash_fn(_jws_hash_str(header, payload), jwk['k'],\n        mod=mod))\n\n    return JWS(header, payload, sig)\n\n\ndef verify(jws, jwk, alg, validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Verifies the given :class:`~jose.JWS`\n\n    :param jws: The :class:`~jose.JWS` to be verified.\n    :param jwk: A `dict` representing the JWK to use for verification. This\n                parameter is algorithm-specific.\n    :param alg: The algorithm to verify the signature with.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, payload, sig = map(b64decode_url, jws)\n    header = json_decode(header)\n    if alg != header['alg']:\n        raise Error('Invalid algorithm')\n\n    (_, verify_fn), mod = JWA[header['alg']]\n\n    if not verify_fn(_jws_hash_str(jws.header, jws.payload),\n            jwk['k'], sig, mod=mod):\n        raise Error('Mismatched signatures')\n\n    claims = json_decode(b64decode_url(jws.payload))\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef b64decode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    istr = encode_safe(istr)\n    try:\n        return urlsafe_b64decode(istr + '=' * (4 - (len(istr) % 4)))\n    except TypeError as e:\n        raise Error('Unable to decode base64: %s' % (e))\n\n\ndef b64encode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    return urlsafe_b64encode(encode_safe(istr)).rstrip('=')\n\n\ndef encode_safe(istr, encoding='utf8'):\n    try:\n        return istr.encode(encoding)\n    except UnicodeDecodeError:\n        # this will fail if istr is already encoded\n        pass\n    return istr\n\n\ndef auth_tag(hmac):\n    # http://tools.ietf.org/html/\n    # draft-ietf-oauth-json-web-token-19#section-4.1.4\n    return hmac[:len(hmac) // 2]\n\n\ndef pad_pkcs7(s):\n    sz = AES.block_size - (len(s) % AES.block_size)\n    return s + (chr(sz) * sz)\n\n\ndef unpad_pkcs7(s):\n    return s[:-ord(s[-1])]\n\n\ndef encrypt_oaep(plaintext, jwk):\n    return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).encrypt(plaintext)\n\n\ndef decrypt_oaep(ciphertext, jwk):\n    try:\n        return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).decrypt(ciphertext)\n    except ValueError as e:\n        raise Error(e.args[0])\n\n\ndef hmac_sign(s, key, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n    return hmac.digest()\n\n\ndef hmac_verify(s, key, sig, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n\n    if not const_compare(hmac.digest(), sig):\n        return False\n\n    return True\n\n\ndef rsa_sign(s, key, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).sign(hash)\n\n\ndef rsa_verify(s, key, sig, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).verify(hash, sig)\n\n\ndef encrypt_aescbc(plaintext, key, iv):\n    plaintext = pad_pkcs7(plaintext)\n    return AES.new(key, AES.MODE_CBC, iv).encrypt(plaintext)\n\n\ndef decrypt_aescbc(ciphertext, key, iv):\n    return unpad_pkcs7(AES.new(key, AES.MODE_CBC, iv).decrypt(ciphertext))\n\n\ndef const_compare(stra, strb):\n    if len(stra) != len(strb):\n        return False\n\n    res = 0\n    for a, b in zip(stra, strb):\n        res |= ord(a) ^ ord(b)\n    return res == 0\n\n\nclass _JWA(object):\n    \&quot;\&quot;\&quot; Represents the implemented algorithms\n\n    A big TODO list can be found here:\n    http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-24\n    \&quot;\&quot;\&quot;\n    _impl = {\n        'HS256': ((hmac_sign, hmac_verify), SHA256),\n        'HS384': ((hmac_sign, hmac_verify), SHA384),\n        'HS512': ((hmac_sign, hmac_verify), SHA512),\n        'RS256': ((rsa_sign, rsa_verify), SHA256),\n        'RS384': ((rsa_sign, rsa_verify), SHA384),\n        'RS512': ((rsa_sign, rsa_verify), SHA512),\n        'RSA-OAEP': ((encrypt_oaep, decrypt_oaep), 2048),\n\n        'A128CBC': ((encrypt_aescbc, decrypt_aescbc), 128),\n        'A192CBC': ((encrypt_aescbc, decrypt_aescbc), 192),\n        'A256CBC': ((encrypt_aescbc, decrypt_aescbc), 256),\n    }\n\n    def __getitem__(self, key):\n        \&quot;\&quot;\&quot; Derive implementation(s) from key\n        \&quot;\&quot;\&quot;\n        if key in self._impl:\n            return self._impl[key]\n\n        enc, hash = self._compound_from_key(key)\n        return self._impl[enc], self._impl[hash]\n\n    def _compound_from_key(self, key):\n        try:\n            enc, hash = key.split('+')\n            return enc, hash\n        except ValueError:\n            pass\n\n        try:\n            enc, hash = key.split('-')\n            return enc, hash\n        except ValueError:\n            pass\n\n        raise Error('Unsupported algorithm: {}'.format(key))\n\n\nJWA = _JWA()\n\n\nCOMPRESSION = {\n    'DEF': (zlib.compress, zlib.decompress),\n}\n\n\ndef _format_timestamp(ts):\n    dt = datetime.datetime.utcfromtimestamp(ts)\n    return dt.isoformat() + 'Z'\n\n\ndef _check_expiration_time(now, expiration_time):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if now &gt;= expiration_time:\n        raise Expired('Token expired at {}'.format(\n            _format_timestamp(expiration_time))\n        )\n\n\ndef _check_not_before(now, not_before):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if not_before &gt; now:\n        raise NotYetValid('Token not valid until {}'.format(\n            _format_timestamp(not_before))\n        )\n\n\ndef _validate(claims, validate_claims, expiry_seconds):\n    \&quot;\&quot;\&quot; Validate expiry related claims.\n\n    If validate_claims is False, do nothing.\n\n    Otherwise, validate the exp and nbf claims if they are present, and\n    validate the iat claim if expiry_seconds is provided.\n    \&quot;\&quot;\&quot;\n    if not validate_claims:\n        return\n\n    now = time()\n\n    # TODO: implement support for clock skew\n\n    # The exp (expiration time) claim identifies the expiration time on or\n    # after which the JWT MUST NOT be accepted for processing. The\n    # processing of the exp claim requires that the current date/time MUST\n    # be before the expiration date/time listed in the exp claim.\n    try:\n        expiration_time = claims[CLAIM_EXPIRATION_TIME]\n    except KeyError:\n        pass\n    else:\n        _check_expiration_time(now, expiration_time)\n\n    # The iat (issued at) claim identifies the time at which the JWT was\n    # issued. This claim can be used to determine the age of the JWT.\n    # If expiry_seconds is provided, and the iat claims is present,\n    # determine the age of the token and check if it has expired.\n    try:\n        issued_at = claims[CLAIM_ISSUED_AT]\n    except KeyError:\n        pass\n    else:\n        if expiry_seconds is not None:\n            _check_expiration_time(now, issued_at + expiry_seconds)\n\n    # The nbf (not before) claim identifies the time before which the JWT\n    # MUST NOT be accepted for processing. The processing of the nbf claim\n    # requires that the current date/time MUST be after or equal to the\n    # not-before date/time listed in the nbf claim.\n    try:\n        not_before = claims[CLAIM_NOT_BEFORE]\n    except KeyError:\n        pass\n    else:\n        _check_not_before(now, not_before)\n\n\ndef _jwe_hash_str(ciphertext, iv, adata='', version=_TEMP_VER):\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-algorithms-24#section-5.2.2.1\n    # Both tokens without version and with version 1 should be ignored in\n    # the future as they use incorrect hashing. The version parameter\n    # should also be removed.\n    if not version:\n        return '.'.join((adata, iv, ciphertext, str(len(adata))))\n    elif version == 1:\n        return '.'.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n    return ''.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n\n\ndef _jws_hash_str(header, claims):\n    return '.'.join((header, claims))\n\n\ndef cli_decrypt(jwt, key):\n    print decrypt(deserialize_compact(jwt), {'k':key},\n        validate_claims=False)\n\n\ndef _cli():\n    import inspect\n    import sys\n\n    from argparse import ArgumentParser\n    from copy import copy\n\n    parser = ArgumentParser()\n    subparsers = parser.add_subparsers(dest='subparser_name')\n\n    commands = {\n        'decrypt': cli_decrypt,\n    }\n    for k, fn in commands.items():\n        p = subparsers.add_parser(k)\n        for arg in inspect.getargspec(fn).args:\n            p.add_argument(arg)\n\n    args = parser.parse_args()\n    handler = commands[args.subparser_name]\n    handler_args = [getattr(args, k) for k in inspect.getargspec(\n        handler).args]\n    handler(*handler_args)\n&quot;},&quot;codebaseEnabled&quot;:true,&quot;ragFiles&quot;:[{&quot;path&quot;:&quot;core/security.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\security.py&quot;,&quot;sources&quot;:[&quot;keyword_search&quot;]},{&quot;path&quot;:&quot;__init__.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\__init__.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\config.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\config.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;agents\\job_creator_agent.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\agents\\job_creator_agent.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;schemas\\auth.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\schemas\\auth.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\database.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\database.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;pyproject.toml&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\pyproject.toml&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;.gitignore&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.gitignore&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;README.md&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\README.md&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;alembic\\alembic.ini&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\alembic\\alembic.ini&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;services\\auth_service.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\services\\auth_service.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\security.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\security.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;api\\routes\\auth.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\api\\routes\\auth.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;models/models.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\models\\models.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;core/security.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\security.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;models/organization.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\models\\organization.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;schemas/auth.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\schemas\\auth.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;schemas/schemas.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\schemas\\schemas.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;services/auth_service.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\services\\auth_service.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;__init__.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\__init__.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;main.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;.env&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.env&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;.venv/Lib/site-packages/jose.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]}],&quot;rerankedFiles&quot;:[{&quot;path&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;,&quot;fsPath&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;},{&quot;path&quot;:&quot;pyproject.toml&quot;,&quot;fsPath&quot;:&quot;pyproject.toml&quot;}],&quot;usedFilePaths&quot;:[{&quot;path&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;],&quot;content&quot;:&quot;import logging\nlogger = logging.getLogger(__name__)\n\ntry:\n    from cjson import encode as json_encode, decode as json_decode\nexcept ImportError:  # pragma: nocover\n    logger.warn('cjson not found, falling back to stdlib json')\n    from json import loads as json_decode, dumps as json_encode\n\nimport zlib\nimport datetime\n\nfrom base64 import urlsafe_b64encode, urlsafe_b64decode\nfrom collections import namedtuple\nfrom copy import deepcopy\nfrom time import time\nfrom struct import pack\n\nfrom Crypto.Hash import HMAC, SHA256, SHA384, SHA512\nfrom Crypto.Cipher import PKCS1_OAEP, AES\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Random import get_random_bytes\nfrom Crypto.Signature import PKCS1_v1_5 as PKCS1_v1_5_SIG\n\n\n__all__ = ['encrypt', 'decrypt', 'sign', 'verify']\n\n\n# XXX: The attribute order is IMPORTANT in the following namedtuple\n# definitions. DO NOT change them, unless you really know what you're doing.\n\nJWE = namedtuple('JWE',\n    'header '\n    'cek '\n    'iv '\n    'ciphertext '\n    'tag ')\n\nJWS = namedtuple('JWS',\n        'header '\n        'payload '\n        'signature ')\n\nJWT = namedtuple('JWT',\n        'header '\n        'claims ')\n\n\nCLAIM_ISSUER = 'iss'\nCLAIM_SUBJECT = 'sub'\nCLAIM_AUDIENCE = 'aud'\nCLAIM_EXPIRATION_TIME = 'exp'\nCLAIM_NOT_BEFORE = 'nbf'\nCLAIM_ISSUED_AT = 'iat'\nCLAIM_JWT_ID = 'jti'\n\n# these are temporary to allow graceful deprecation of legacy encrypted tokens.\n# these will be removed in v1.0\n_TEMP_VER_KEY = '__v'\n_TEMP_VER = 2\n\n\nclass Error(Exception):\n    \&quot;\&quot;\&quot; The base error type raised by jose\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass Expired(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation if a JWT has expired\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass NotYetValid(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation is a JWT is not yet valid\n    \&quot;\&quot;\&quot;\n    pass\n\n\ndef serialize_compact(jwt):\n    \&quot;\&quot;\&quot; Compact serialization of a :class:`~jose.JWE` or :class:`~jose.JWS`\n\n    :rtype: str\n    :returns: A string, representing the compact serialization of a\n              :class:`~jose.JWE` or :class:`~jose.JWS`.\n    \&quot;\&quot;\&quot;\n    return '.'.join(jwt)\n\n\ndef deserialize_compact(jwt):\n    \&quot;\&quot;\&quot; Deserialization of a compact representation of a :class:`~jwt.JWE`\n\n    :param jwt: The serialized JWT to deserialize.\n    :rtype: :class:`~jose.JWT`.\n    :raises: :class:`~jose.Error` if the JWT is malformed\n    \&quot;\&quot;\&quot;\n    parts = jwt.split('.')\n\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-encryption-23#section-9\n    if len(parts) == 3:\n        token_type = JWS\n    elif len(parts) == 5:\n        token_type = JWE\n    else:\n        raise Error('Malformed JWT')\n\n    return token_type(*parts)\n\n\ndef encrypt(claims, jwk, adata='', add_header=None, alg='RSA-OAEP',\n        enc='A128CBC-HS256', rng=get_random_bytes, compression=None):\n    \&quot;\&quot;\&quot; Encrypts the given claims and produces a :class:`~jose.JWE`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWE`.\n    :param jwk: A `dict` representing the JWK to be used for encryption of\n                the CEK. This parameter is algorithm-specific.\n    :param adata: Arbitrary string data to add to the authentication\n                  (i.e. HMAC). The same data must be provided during\n                  decryption.\n    :param add_header: Additional items to be added to the header. Additional\n                       headers *will* be authenticated.\n    :param alg: The algorithm to use for CEK encryption\n    :param enc: The algorithm to use for claims encryption\n    :param rng: Random number generator. A string of random bytes is expected\n                as output.\n    :param compression: The compression algorithm to use. Currently supports\n                `'DEF'`.\n    :rtype: :class:`~jose.JWE`\n    :raises: :class:`~jose.Error` if there is an error producing the JWE\n    \&quot;\&quot;\&quot;\n    # copy so the injected claim doesn't mutate the input claims\n    # this is a temporary hack to allow for graceful deprecation of tokens,\n    # ensuring that the library can still handle decrypting tokens issued\n    # before the implementation of the fix\n    claims = deepcopy(claims)\n    assert _TEMP_VER_KEY not in claims\n    claims[_TEMP_VER_KEY] = _TEMP_VER\n\n    header = dict((add_header or {}).items() + [\n        ('enc', enc), ('alg', alg)])\n\n    # promote the temp key to the header\n    assert _TEMP_VER_KEY not in header\n    header[_TEMP_VER_KEY] = claims[_TEMP_VER_KEY]\n\n    plaintext = json_encode(claims)\n\n    # compress (if required)\n    if compression is not None:\n        header['zip'] = compression\n        try:\n            (compress, _) = COMPRESSION[compression]\n        except KeyError:\n            raise Error(\n                'Unsupported compression algorithm: {}'.format(compression))\n        plaintext = compress(plaintext)\n\n    # body encryption/hash\n    ((cipher, _), key_size), ((hash_fn, _), hash_mod) = JWA[enc]\n    iv = rng(AES.block_size)\n    encryption_key = rng(hash_mod.digest_size)\n\n    ciphertext = cipher(plaintext, encryption_key[-hash_mod.digest_size/2:], iv)\n    hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata),\n            encryption_key[:-hash_mod.digest_size/2], hash_mod)\n\n    # cek encryption\n    (cipher, _), _ = JWA[alg]\n    encryption_key_ciphertext = cipher(encryption_key, jwk)\n\n    return JWE(*map(b64encode_url,\n            (json_encode(header),\n            encryption_key_ciphertext,\n            iv,\n            ciphertext,\n            auth_tag(hash))))\n\n\ndef decrypt(jwe, jwk, adata='', validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Decrypts a deserialized :class:`~jose.JWE`\n\n    :param jwe: An instance of :class:`~jose.JWE`\n    :param jwk: A `dict` representing the JWK required to decrypt the content\n                of the :class:`~jose.JWE`.\n    :param adata: Arbitrary string data used during encryption for additional\n                  authentication.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, encryption_key_ciphertext, iv, ciphertext, tag = map(\n        b64decode_url, jwe)\n    header = json_decode(header)\n\n    # decrypt cek\n    (_, decipher), _ = JWA[header['alg']]\n    encryption_key = decipher(encryption_key_ciphertext, jwk)\n\n    # decrypt body\n    ((_, decipher), _), ((hash_fn, _), mod) = JWA[header['enc']]\n\n    version = header.get(_TEMP_VER_KEY)\n    if version:\n        plaintext = decipher(ciphertext, encryption_key[-mod.digest_size/2:], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n                encryption_key[:-mod.digest_size/2], mod=mod)\n    else:\n        plaintext = decipher(ciphertext, encryption_key[:-mod.digest_size], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n            encryption_key[-mod.digest_size:], mod=mod)\n\n    if not const_compare(auth_tag(hash), tag):\n        raise Error('Mismatched authentication tags')\n\n    if 'zip' in header:\n        try:\n            (_, decompress) = COMPRESSION[header['zip']]\n        except KeyError:\n            raise Error('Unsupported compression algorithm: {}'.format(\n                header['zip']))\n\n        plaintext = decompress(plaintext)\n\n    claims = json_decode(plaintext)\n    try:\n        del claims[_TEMP_VER_KEY]\n    except KeyError:\n        # expected when decrypting legacy tokens\n        pass\n\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef sign(claims, jwk, add_header=None, alg='HS256'):\n    \&quot;\&quot;\&quot; Signs the given claims and produces a :class:`~jose.JWS`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWS`.\n    :param jwk: A `dict` representing the JWK to be used for signing of the\n                :class:`~jose.JWS`. This parameter is algorithm-specific.\n    :parameter add_header: Additional items to be added to the header.\n                           Additional headers *will* be authenticated.\n    :parameter alg: The algorithm to use to produce the signature.\n    :rtype: :class:`~jose.JWS`\n    \&quot;\&quot;\&quot;\n    (hash_fn, _), mod = JWA[alg]\n\n    header = dict((add_header or {}).items() + [('alg', alg)])\n    header, payload = map(b64encode_url, map(json_encode, (header, claims)))\n\n    sig = b64encode_url(hash_fn(_jws_hash_str(header, payload), jwk['k'],\n        mod=mod))\n\n    return JWS(header, payload, sig)\n\n\ndef verify(jws, jwk, alg, validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Verifies the given :class:`~jose.JWS`\n\n    :param jws: The :class:`~jose.JWS` to be verified.\n    :param jwk: A `dict` representing the JWK to use for verification. This\n                parameter is algorithm-specific.\n    :param alg: The algorithm to verify the signature with.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, payload, sig = map(b64decode_url, jws)\n    header = json_decode(header)\n    if alg != header['alg']:\n        raise Error('Invalid algorithm')\n\n    (_, verify_fn), mod = JWA[header['alg']]\n\n    if not verify_fn(_jws_hash_str(jws.header, jws.payload),\n            jwk['k'], sig, mod=mod):\n        raise Error('Mismatched signatures')\n\n    claims = json_decode(b64decode_url(jws.payload))\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef b64decode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    istr = encode_safe(istr)\n    try:\n        return urlsafe_b64decode(istr + '=' * (4 - (len(istr) % 4)))\n    except TypeError as e:\n        raise Error('Unable to decode base64: %s' % (e))\n\n\ndef b64encode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    return urlsafe_b64encode(encode_safe(istr)).rstrip('=')\n\n\ndef encode_safe(istr, encoding='utf8'):\n    try:\n        return istr.encode(encoding)\n    except UnicodeDecodeError:\n        # this will fail if istr is already encoded\n        pass\n    return istr\n\n\ndef auth_tag(hmac):\n    # http://tools.ietf.org/html/\n    # draft-ietf-oauth-json-web-token-19#section-4.1.4\n    return hmac[:len(hmac) // 2]\n\n\ndef pad_pkcs7(s):\n    sz = AES.block_size - (len(s) % AES.block_size)\n    return s + (chr(sz) * sz)\n\n\ndef unpad_pkcs7(s):\n    return s[:-ord(s[-1])]\n\n\ndef encrypt_oaep(plaintext, jwk):\n    return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).encrypt(plaintext)\n\n\ndef decrypt_oaep(ciphertext, jwk):\n    try:\n        return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).decrypt(ciphertext)\n    except ValueError as e:\n        raise Error(e.args[0])\n\n\ndef hmac_sign(s, key, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n    return hmac.digest()\n\n\ndef hmac_verify(s, key, sig, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n\n    if not const_compare(hmac.digest(), sig):\n        return False\n\n    return True\n\n\ndef rsa_sign(s, key, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).sign(hash)\n\n\ndef rsa_verify(s, key, sig, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).verify(hash, sig)\n\n\ndef encrypt_aescbc(plaintext, key, iv):\n    plaintext = pad_pkcs7(plaintext)\n    return AES.new(key, AES.MODE_CBC, iv).encrypt(plaintext)\n\n\ndef decrypt_aescbc(ciphertext, key, iv):\n    return unpad_pkcs7(AES.new(key, AES.MODE_CBC, iv).decrypt(ciphertext))\n\n\ndef const_compare(stra, strb):\n    if len(stra) != len(strb):\n        return False\n\n    res = 0\n    for a, b in zip(stra, strb):\n        res |= ord(a) ^ ord(b)\n    return res == 0\n\n\nclass _JWA(object):\n    \&quot;\&quot;\&quot; Represents the implemented algorithms\n\n    A big TODO list can be found here:\n    http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-24\n    \&quot;\&quot;\&quot;\n    _impl = {\n        'HS256': ((hmac_sign, hmac_verify), SHA256),\n        'HS384': ((hmac_sign, hmac_verify), SHA384),\n        'HS512': ((hmac_sign, hmac_verify), SHA512),\n        'RS256': ((rsa_sign, rsa_verify), SHA256),\n        'RS384': ((rsa_sign, rsa_verify), SHA384),\n        'RS512': ((rsa_sign, rsa_verify), SHA512),\n        'RSA-OAEP': ((encrypt_oaep, decrypt_oaep), 2048),\n\n        'A128CBC': ((encrypt_aescbc, decrypt_aescbc), 128),\n        'A192CBC': ((encrypt_aescbc, decrypt_aescbc), 192),\n        'A256CBC': ((encrypt_aescbc, decrypt_aescbc), 256),\n    }\n\n    def __getitem__(self, key):\n        \&quot;\&quot;\&quot; Derive implementation(s) from key\n        \&quot;\&quot;\&quot;\n        if key in self._impl:\n            return self._impl[key]\n\n        enc, hash = self._compound_from_key(key)\n        return self._impl[enc], self._impl[hash]\n\n    def _compound_from_key(self, key):\n        try:\n            enc, hash = key.split('+')\n            return enc, hash\n        except ValueError:\n            pass\n\n        try:\n            enc, hash = key.split('-')\n            return enc, hash\n        except ValueError:\n            pass\n\n        raise Error('Unsupported algorithm: {}'.format(key))\n\n\nJWA = _JWA()\n\n\nCOMPRESSION = {\n    'DEF': (zlib.compress, zlib.decompress),\n}\n\n\ndef _format_timestamp(ts):\n    dt = datetime.datetime.utcfromtimestamp(ts)\n    return dt.isoformat() + 'Z'\n\n\ndef _check_expiration_time(now, expiration_time):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if now &gt;= expiration_time:\n        raise Expired('Token expired at {}'.format(\n            _format_timestamp(expiration_time))\n        )\n\n\ndef _check_not_before(now, not_before):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if not_before &gt; now:\n        raise NotYetValid('Token not valid until {}'.format(\n            _format_timestamp(not_before))\n        )\n\n\ndef _validate(claims, validate_claims, expiry_seconds):\n    \&quot;\&quot;\&quot; Validate expiry related claims.\n\n    If validate_claims is False, do nothing.\n\n    Otherwise, validate the exp and nbf claims if they are present, and\n    validate the iat claim if expiry_seconds is provided.\n    \&quot;\&quot;\&quot;\n    if not validate_claims:\n        return\n\n    now = time()\n\n    # TODO: implement support for clock skew\n\n    # The exp (expiration time) claim identifies the expiration time on or\n    # after which the JWT MUST NOT be accepted for processing. The\n    # processing of the exp claim requires that the current date/time MUST\n    # be before the expiration date/time listed in the exp claim.\n    try:\n        expiration_time = claims[CLAIM_EXPIRATION_TIME]\n    except KeyError:\n        pass\n    else:\n        _check_expiration_time(now, expiration_time)\n\n    # The iat (issued at) claim identifies the time at which the JWT was\n    # issued. This claim can be used to determine the age of the JWT.\n    # If expiry_seconds is provided, and the iat claims is present,\n    # determine the age of the token and check if it has expired.\n    try:\n        issued_at = claims[CLAIM_ISSUED_AT]\n    except KeyError:\n        pass\n    else:\n        if expiry_seconds is not None:\n            _check_expiration_time(now, issued_at + expiry_seconds)\n\n    # The nbf (not before) claim identifies the time before which the JWT\n    # MUST NOT be accepted for processing. The processing of the nbf claim\n    # requires that the current date/time MUST be after or equal to the\n    # not-before date/time listed in the nbf claim.\n    try:\n        not_before = claims[CLAIM_NOT_BEFORE]\n    except KeyError:\n        pass\n    else:\n        _check_not_before(now, not_before)\n\n\ndef _jwe_hash_str(ciphertext, iv, adata='', version=_TEMP_VER):\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-algorithms-24#section-5.2.2.1\n    # Both tokens without version and with version 1 should be ignored in\n    # the future as they use incorrect hashing. The version parameter\n    # should also be removed.\n    if not version:\n        return '.'.join((adata, iv, ciphertext, str(len(adata))))\n    elif version == 1:\n        return '.'.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n    return ''.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n\n\ndef _jws_hash_str(header, claims):\n    return '.'.join((header, claims))\n\n\ndef cli_decrypt(jwt, key):\n    print decrypt(deserialize_compact(jwt), {'k':key},\n        validate_claims=False)\n\n\ndef _cli():\n    import inspect\n    import sys\n\n    from argparse import ArgumentParser\n    from copy import copy\n\n    parser = ArgumentParser()\n    subparsers = parser.add_subparsers(dest='subparser_name')\n\n    commands = {\n        'decrypt': cli_decrypt,\n    }\n    for k, fn in commands.items():\n        p = subparsers.add_parser(k)\n        for arg in inspect.getargspec(fn).args:\n            p.add_argument(arg)\n\n    args = parser.parse_args()\n    handler = commands[args.subparser_name]\n    handler_args = [getattr(args, k) for k in inspect.getargspec(\n        handler).args]\n    handler(*handler_args)\n&quot;},{&quot;path&quot;:&quot;pyproject.toml&quot;,&quot;fsPath&quot;:&quot;pyproject.toml&quot;}]},&quot;createdAt&quot;:1751746575721,&quot;isInternal&quot;:false},{&quot;id&quot;:&quot;c3eebecc-2793-4126-a08c-4d264796ce62&quot;,&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;stills&quot;}],&quot;context&quot;:{&quot;currentFile&quot;:{&quot;path&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;],&quot;content&quot;:&quot;import logging\nlogger = logging.getLogger(__name__)\n\ntry:\n    from cjson import encode as json_encode, decode as json_decode\nexcept ImportError:  # pragma: nocover\n    logger.warn('cjson not found, falling back to stdlib json')\n    from json import loads as json_decode, dumps as json_encode\n\nimport zlib\nimport datetime\n\nfrom base64 import urlsafe_b64encode, urlsafe_b64decode\nfrom collections import namedtuple\nfrom copy import deepcopy\nfrom time import time\nfrom struct import pack\n\nfrom Crypto.Hash import HMAC, SHA256, SHA384, SHA512\nfrom Crypto.Cipher import PKCS1_OAEP, AES\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Random import get_random_bytes\nfrom Crypto.Signature import PKCS1_v1_5 as PKCS1_v1_5_SIG\n\n\n__all__ = ['encrypt', 'decrypt', 'sign', 'verify']\n\n\n# XXX: The attribute order is IMPORTANT in the following namedtuple\n# definitions. DO NOT change them, unless you really know what you're doing.\n\nJWE = namedtuple('JWE',\n    'header '\n    'cek '\n    'iv '\n    'ciphertext '\n    'tag ')\n\nJWS = namedtuple('JWS',\n        'header '\n        'payload '\n        'signature ')\n\nJWT = namedtuple('JWT',\n        'header '\n        'claims ')\n\n\nCLAIM_ISSUER = 'iss'\nCLAIM_SUBJECT = 'sub'\nCLAIM_AUDIENCE = 'aud'\nCLAIM_EXPIRATION_TIME = 'exp'\nCLAIM_NOT_BEFORE = 'nbf'\nCLAIM_ISSUED_AT = 'iat'\nCLAIM_JWT_ID = 'jti'\n\n# these are temporary to allow graceful deprecation of legacy encrypted tokens.\n# these will be removed in v1.0\n_TEMP_VER_KEY = '__v'\n_TEMP_VER = 2\n\n\nclass Error(Exception):\n    \&quot;\&quot;\&quot; The base error type raised by jose\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass Expired(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation if a JWT has expired\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass NotYetValid(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation is a JWT is not yet valid\n    \&quot;\&quot;\&quot;\n    pass\n\n\ndef serialize_compact(jwt):\n    \&quot;\&quot;\&quot; Compact serialization of a :class:`~jose.JWE` or :class:`~jose.JWS`\n\n    :rtype: str\n    :returns: A string, representing the compact serialization of a\n              :class:`~jose.JWE` or :class:`~jose.JWS`.\n    \&quot;\&quot;\&quot;\n    return '.'.join(jwt)\n\n\ndef deserialize_compact(jwt):\n    \&quot;\&quot;\&quot; Deserialization of a compact representation of a :class:`~jwt.JWE`\n\n    :param jwt: The serialized JWT to deserialize.\n    :rtype: :class:`~jose.JWT`.\n    :raises: :class:`~jose.Error` if the JWT is malformed\n    \&quot;\&quot;\&quot;\n    parts = jwt.split('.')\n\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-encryption-23#section-9\n    if len(parts) == 3:\n        token_type = JWS\n    elif len(parts) == 5:\n        token_type = JWE\n    else:\n        raise Error('Malformed JWT')\n\n    return token_type(*parts)\n\n\ndef encrypt(claims, jwk, adata='', add_header=None, alg='RSA-OAEP',\n        enc='A128CBC-HS256', rng=get_random_bytes, compression=None):\n    \&quot;\&quot;\&quot; Encrypts the given claims and produces a :class:`~jose.JWE`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWE`.\n    :param jwk: A `dict` representing the JWK to be used for encryption of\n                the CEK. This parameter is algorithm-specific.\n    :param adata: Arbitrary string data to add to the authentication\n                  (i.e. HMAC). The same data must be provided during\n                  decryption.\n    :param add_header: Additional items to be added to the header. Additional\n                       headers *will* be authenticated.\n    :param alg: The algorithm to use for CEK encryption\n    :param enc: The algorithm to use for claims encryption\n    :param rng: Random number generator. A string of random bytes is expected\n                as output.\n    :param compression: The compression algorithm to use. Currently supports\n                `'DEF'`.\n    :rtype: :class:`~jose.JWE`\n    :raises: :class:`~jose.Error` if there is an error producing the JWE\n    \&quot;\&quot;\&quot;\n    # copy so the injected claim doesn't mutate the input claims\n    # this is a temporary hack to allow for graceful deprecation of tokens,\n    # ensuring that the library can still handle decrypting tokens issued\n    # before the implementation of the fix\n    claims = deepcopy(claims)\n    assert _TEMP_VER_KEY not in claims\n    claims[_TEMP_VER_KEY] = _TEMP_VER\n\n    header = dict((add_header or {}).items() + [\n        ('enc', enc), ('alg', alg)])\n\n    # promote the temp key to the header\n    assert _TEMP_VER_KEY not in header\n    header[_TEMP_VER_KEY] = claims[_TEMP_VER_KEY]\n\n    plaintext = json_encode(claims)\n\n    # compress (if required)\n    if compression is not None:\n        header['zip'] = compression\n        try:\n            (compress, _) = COMPRESSION[compression]\n        except KeyError:\n            raise Error(\n                'Unsupported compression algorithm: {}'.format(compression))\n        plaintext = compress(plaintext)\n\n    # body encryption/hash\n    ((cipher, _), key_size), ((hash_fn, _), hash_mod) = JWA[enc]\n    iv = rng(AES.block_size)\n    encryption_key = rng(hash_mod.digest_size)\n\n    ciphertext = cipher(plaintext, encryption_key[-hash_mod.digest_size/2:], iv)\n    hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata),\n            encryption_key[:-hash_mod.digest_size/2], hash_mod)\n\n    # cek encryption\n    (cipher, _), _ = JWA[alg]\n    encryption_key_ciphertext = cipher(encryption_key, jwk)\n\n    return JWE(*map(b64encode_url,\n            (json_encode(header),\n            encryption_key_ciphertext,\n            iv,\n            ciphertext,\n            auth_tag(hash))))\n\n\ndef decrypt(jwe, jwk, adata='', validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Decrypts a deserialized :class:`~jose.JWE`\n\n    :param jwe: An instance of :class:`~jose.JWE`\n    :param jwk: A `dict` representing the JWK required to decrypt the content\n                of the :class:`~jose.JWE`.\n    :param adata: Arbitrary string data used during encryption for additional\n                  authentication.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, encryption_key_ciphertext, iv, ciphertext, tag = map(\n        b64decode_url, jwe)\n    header = json_decode(header)\n\n    # decrypt cek\n    (_, decipher), _ = JWA[header['alg']]\n    encryption_key = decipher(encryption_key_ciphertext, jwk)\n\n    # decrypt body\n    ((_, decipher), _), ((hash_fn, _), mod) = JWA[header['enc']]\n\n    version = header.get(_TEMP_VER_KEY)\n    if version:\n        plaintext = decipher(ciphertext, encryption_key[-mod.digest_size/2:], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n                encryption_key[:-mod.digest_size/2], mod=mod)\n    else:\n        plaintext = decipher(ciphertext, encryption_key[:-mod.digest_size], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n            encryption_key[-mod.digest_size:], mod=mod)\n\n    if not const_compare(auth_tag(hash), tag):\n        raise Error('Mismatched authentication tags')\n\n    if 'zip' in header:\n        try:\n            (_, decompress) = COMPRESSION[header['zip']]\n        except KeyError:\n            raise Error('Unsupported compression algorithm: {}'.format(\n                header['zip']))\n\n        plaintext = decompress(plaintext)\n\n    claims = json_decode(plaintext)\n    try:\n        del claims[_TEMP_VER_KEY]\n    except KeyError:\n        # expected when decrypting legacy tokens\n        pass\n\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef sign(claims, jwk, add_header=None, alg='HS256'):\n    \&quot;\&quot;\&quot; Signs the given claims and produces a :class:`~jose.JWS`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWS`.\n    :param jwk: A `dict` representing the JWK to be used for signing of the\n                :class:`~jose.JWS`. This parameter is algorithm-specific.\n    :parameter add_header: Additional items to be added to the header.\n                           Additional headers *will* be authenticated.\n    :parameter alg: The algorithm to use to produce the signature.\n    :rtype: :class:`~jose.JWS`\n    \&quot;\&quot;\&quot;\n    (hash_fn, _), mod = JWA[alg]\n\n    header = dict((add_header or {}).items() + [('alg', alg)])\n    header, payload = map(b64encode_url, map(json_encode, (header, claims)))\n\n    sig = b64encode_url(hash_fn(_jws_hash_str(header, payload), jwk['k'],\n        mod=mod))\n\n    return JWS(header, payload, sig)\n\n\ndef verify(jws, jwk, alg, validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Verifies the given :class:`~jose.JWS`\n\n    :param jws: The :class:`~jose.JWS` to be verified.\n    :param jwk: A `dict` representing the JWK to use for verification. This\n                parameter is algorithm-specific.\n    :param alg: The algorithm to verify the signature with.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, payload, sig = map(b64decode_url, jws)\n    header = json_decode(header)\n    if alg != header['alg']:\n        raise Error('Invalid algorithm')\n\n    (_, verify_fn), mod = JWA[header['alg']]\n\n    if not verify_fn(_jws_hash_str(jws.header, jws.payload),\n            jwk['k'], sig, mod=mod):\n        raise Error('Mismatched signatures')\n\n    claims = json_decode(b64decode_url(jws.payload))\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef b64decode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    istr = encode_safe(istr)\n    try:\n        return urlsafe_b64decode(istr + '=' * (4 - (len(istr) % 4)))\n    except TypeError as e:\n        raise Error('Unable to decode base64: %s' % (e))\n\n\ndef b64encode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    return urlsafe_b64encode(encode_safe(istr)).rstrip('=')\n\n\ndef encode_safe(istr, encoding='utf8'):\n    try:\n        return istr.encode(encoding)\n    except UnicodeDecodeError:\n        # this will fail if istr is already encoded\n        pass\n    return istr\n\n\ndef auth_tag(hmac):\n    # http://tools.ietf.org/html/\n    # draft-ietf-oauth-json-web-token-19#section-4.1.4\n    return hmac[:len(hmac) // 2]\n\n\ndef pad_pkcs7(s):\n    sz = AES.block_size - (len(s) % AES.block_size)\n    return s + (chr(sz) * sz)\n\n\ndef unpad_pkcs7(s):\n    return s[:-ord(s[-1])]\n\n\ndef encrypt_oaep(plaintext, jwk):\n    return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).encrypt(plaintext)\n\n\ndef decrypt_oaep(ciphertext, jwk):\n    try:\n        return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).decrypt(ciphertext)\n    except ValueError as e:\n        raise Error(e.args[0])\n\n\ndef hmac_sign(s, key, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n    return hmac.digest()\n\n\ndef hmac_verify(s, key, sig, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n\n    if not const_compare(hmac.digest(), sig):\n        return False\n\n    return True\n\n\ndef rsa_sign(s, key, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).sign(hash)\n\n\ndef rsa_verify(s, key, sig, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).verify(hash, sig)\n\n\ndef encrypt_aescbc(plaintext, key, iv):\n    plaintext = pad_pkcs7(plaintext)\n    return AES.new(key, AES.MODE_CBC, iv).encrypt(plaintext)\n\n\ndef decrypt_aescbc(ciphertext, key, iv):\n    return unpad_pkcs7(AES.new(key, AES.MODE_CBC, iv).decrypt(ciphertext))\n\n\ndef const_compare(stra, strb):\n    if len(stra) != len(strb):\n        return False\n\n    res = 0\n    for a, b in zip(stra, strb):\n        res |= ord(a) ^ ord(b)\n    return res == 0\n\n\nclass _JWA(object):\n    \&quot;\&quot;\&quot; Represents the implemented algorithms\n\n    A big TODO list can be found here:\n    http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-24\n    \&quot;\&quot;\&quot;\n    _impl = {\n        'HS256': ((hmac_sign, hmac_verify), SHA256),\n        'HS384': ((hmac_sign, hmac_verify), SHA384),\n        'HS512': ((hmac_sign, hmac_verify), SHA512),\n        'RS256': ((rsa_sign, rsa_verify), SHA256),\n        'RS384': ((rsa_sign, rsa_verify), SHA384),\n        'RS512': ((rsa_sign, rsa_verify), SHA512),\n        'RSA-OAEP': ((encrypt_oaep, decrypt_oaep), 2048),\n\n        'A128CBC': ((encrypt_aescbc, decrypt_aescbc), 128),\n        'A192CBC': ((encrypt_aescbc, decrypt_aescbc), 192),\n        'A256CBC': ((encrypt_aescbc, decrypt_aescbc), 256),\n    }\n\n    def __getitem__(self, key):\n        \&quot;\&quot;\&quot; Derive implementation(s) from key\n        \&quot;\&quot;\&quot;\n        if key in self._impl:\n            return self._impl[key]\n\n        enc, hash = self._compound_from_key(key)\n        return self._impl[enc], self._impl[hash]\n\n    def _compound_from_key(self, key):\n        try:\n            enc, hash = key.split('+')\n            return enc, hash\n        except ValueError:\n            pass\n\n        try:\n            enc, hash = key.split('-')\n            return enc, hash\n        except ValueError:\n            pass\n\n        raise Error('Unsupported algorithm: {}'.format(key))\n\n\nJWA = _JWA()\n\n\nCOMPRESSION = {\n    'DEF': (zlib.compress, zlib.decompress),\n}\n\n\ndef _format_timestamp(ts):\n    dt = datetime.datetime.utcfromtimestamp(ts)\n    return dt.isoformat() + 'Z'\n\n\ndef _check_expiration_time(now, expiration_time):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if now &gt;= expiration_time:\n        raise Expired('Token expired at {}'.format(\n            _format_timestamp(expiration_time))\n        )\n\n\ndef _check_not_before(now, not_before):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if not_before &gt; now:\n        raise NotYetValid('Token not valid until {}'.format(\n            _format_timestamp(not_before))\n        )\n\n\ndef _validate(claims, validate_claims, expiry_seconds):\n    \&quot;\&quot;\&quot; Validate expiry related claims.\n\n    If validate_claims is False, do nothing.\n\n    Otherwise, validate the exp and nbf claims if they are present, and\n    validate the iat claim if expiry_seconds is provided.\n    \&quot;\&quot;\&quot;\n    if not validate_claims:\n        return\n\n    now = time()\n\n    # TODO: implement support for clock skew\n\n    # The exp (expiration time) claim identifies the expiration time on or\n    # after which the JWT MUST NOT be accepted for processing. The\n    # processing of the exp claim requires that the current date/time MUST\n    # be before the expiration date/time listed in the exp claim.\n    try:\n        expiration_time = claims[CLAIM_EXPIRATION_TIME]\n    except KeyError:\n        pass\n    else:\n        _check_expiration_time(now, expiration_time)\n\n    # The iat (issued at) claim identifies the time at which the JWT was\n    # issued. This claim can be used to determine the age of the JWT.\n    # If expiry_seconds is provided, and the iat claims is present,\n    # determine the age of the token and check if it has expired.\n    try:\n        issued_at = claims[CLAIM_ISSUED_AT]\n    except KeyError:\n        pass\n    else:\n        if expiry_seconds is not None:\n            _check_expiration_time(now, issued_at + expiry_seconds)\n\n    # The nbf (not before) claim identifies the time before which the JWT\n    # MUST NOT be accepted for processing. The processing of the nbf claim\n    # requires that the current date/time MUST be after or equal to the\n    # not-before date/time listed in the nbf claim.\n    try:\n        not_before = claims[CLAIM_NOT_BEFORE]\n    except KeyError:\n        pass\n    else:\n        _check_not_before(now, not_before)\n\n\ndef _jwe_hash_str(ciphertext, iv, adata='', version=_TEMP_VER):\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-algorithms-24#section-5.2.2.1\n    # Both tokens without version and with version 1 should be ignored in\n    # the future as they use incorrect hashing. The version parameter\n    # should also be removed.\n    if not version:\n        return '.'.join((adata, iv, ciphertext, str(len(adata))))\n    elif version == 1:\n        return '.'.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n    return ''.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n\n\ndef _jws_hash_str(header, claims):\n    return '.'.join((header, claims))\n\n\ndef cli_decrypt(jwt, key):\n    print decrypt(deserialize_compact(jwt), {'k':key},\n        validate_claims=False)\n\n\ndef _cli():\n    import inspect\n    import sys\n\n    from argparse import ArgumentParser\n    from copy import copy\n\n    parser = ArgumentParser()\n    subparsers = parser.add_subparsers(dest='subparser_name')\n\n    commands = {\n        'decrypt': cli_decrypt,\n    }\n    for k, fn in commands.items():\n        p = subparsers.add_parser(k)\n        for arg in inspect.getargspec(fn).args:\n            p.add_argument(arg)\n\n    args = parser.parse_args()\n    handler = commands[args.subparser_name]\n    handler_args = [getattr(args, k) for k in inspect.getargspec(\n        handler).args]\n    handler(*handler_args)\n&quot;},&quot;codebaseEnabled&quot;:true,&quot;ragFiles&quot;:[{&quot;path&quot;:&quot;agents\\job_creator_agent.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\agents\\job_creator_agent.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;schemas\\auth.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\schemas\\auth.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\config.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\config.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\database.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\database.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;models\\models.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\models\\models.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;.gitignore&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.gitignore&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;alembic\\alembic.ini&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\alembic\\alembic.ini&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;README.md&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\README.md&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;pyproject.toml&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\pyproject.toml&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;models/models.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\models\\models.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;core/security.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\security.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;models/organization.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\models\\organization.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;schemas/auth.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\schemas\\auth.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;schemas/schemas.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\schemas\\schemas.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;services/auth_service.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\services\\auth_service.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;__init__.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\__init__.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;main.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;.env&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.env&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;.venv/Lib/site-packages/jose.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]}],&quot;rerankedFiles&quot;:[],&quot;usedFilePaths&quot;:[{&quot;path&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;],&quot;content&quot;:&quot;import logging\nlogger = logging.getLogger(__name__)\n\ntry:\n    from cjson import encode as json_encode, decode as json_decode\nexcept ImportError:  # pragma: nocover\n    logger.warn('cjson not found, falling back to stdlib json')\n    from json import loads as json_decode, dumps as json_encode\n\nimport zlib\nimport datetime\n\nfrom base64 import urlsafe_b64encode, urlsafe_b64decode\nfrom collections import namedtuple\nfrom copy import deepcopy\nfrom time import time\nfrom struct import pack\n\nfrom Crypto.Hash import HMAC, SHA256, SHA384, SHA512\nfrom Crypto.Cipher import PKCS1_OAEP, AES\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Random import get_random_bytes\nfrom Crypto.Signature import PKCS1_v1_5 as PKCS1_v1_5_SIG\n\n\n__all__ = ['encrypt', 'decrypt', 'sign', 'verify']\n\n\n# XXX: The attribute order is IMPORTANT in the following namedtuple\n# definitions. DO NOT change them, unless you really know what you're doing.\n\nJWE = namedtuple('JWE',\n    'header '\n    'cek '\n    'iv '\n    'ciphertext '\n    'tag ')\n\nJWS = namedtuple('JWS',\n        'header '\n        'payload '\n        'signature ')\n\nJWT = namedtuple('JWT',\n        'header '\n        'claims ')\n\n\nCLAIM_ISSUER = 'iss'\nCLAIM_SUBJECT = 'sub'\nCLAIM_AUDIENCE = 'aud'\nCLAIM_EXPIRATION_TIME = 'exp'\nCLAIM_NOT_BEFORE = 'nbf'\nCLAIM_ISSUED_AT = 'iat'\nCLAIM_JWT_ID = 'jti'\n\n# these are temporary to allow graceful deprecation of legacy encrypted tokens.\n# these will be removed in v1.0\n_TEMP_VER_KEY = '__v'\n_TEMP_VER = 2\n\n\nclass Error(Exception):\n    \&quot;\&quot;\&quot; The base error type raised by jose\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass Expired(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation if a JWT has expired\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass NotYetValid(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation is a JWT is not yet valid\n    \&quot;\&quot;\&quot;\n    pass\n\n\ndef serialize_compact(jwt):\n    \&quot;\&quot;\&quot; Compact serialization of a :class:`~jose.JWE` or :class:`~jose.JWS`\n\n    :rtype: str\n    :returns: A string, representing the compact serialization of a\n              :class:`~jose.JWE` or :class:`~jose.JWS`.\n    \&quot;\&quot;\&quot;\n    return '.'.join(jwt)\n\n\ndef deserialize_compact(jwt):\n    \&quot;\&quot;\&quot; Deserialization of a compact representation of a :class:`~jwt.JWE`\n\n    :param jwt: The serialized JWT to deserialize.\n    :rtype: :class:`~jose.JWT`.\n    :raises: :class:`~jose.Error` if the JWT is malformed\n    \&quot;\&quot;\&quot;\n    parts = jwt.split('.')\n\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-encryption-23#section-9\n    if len(parts) == 3:\n        token_type = JWS\n    elif len(parts) == 5:\n        token_type = JWE\n    else:\n        raise Error('Malformed JWT')\n\n    return token_type(*parts)\n\n\ndef encrypt(claims, jwk, adata='', add_header=None, alg='RSA-OAEP',\n        enc='A128CBC-HS256', rng=get_random_bytes, compression=None):\n    \&quot;\&quot;\&quot; Encrypts the given claims and produces a :class:`~jose.JWE`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWE`.\n    :param jwk: A `dict` representing the JWK to be used for encryption of\n                the CEK. This parameter is algorithm-specific.\n    :param adata: Arbitrary string data to add to the authentication\n                  (i.e. HMAC). The same data must be provided during\n                  decryption.\n    :param add_header: Additional items to be added to the header. Additional\n                       headers *will* be authenticated.\n    :param alg: The algorithm to use for CEK encryption\n    :param enc: The algorithm to use for claims encryption\n    :param rng: Random number generator. A string of random bytes is expected\n                as output.\n    :param compression: The compression algorithm to use. Currently supports\n                `'DEF'`.\n    :rtype: :class:`~jose.JWE`\n    :raises: :class:`~jose.Error` if there is an error producing the JWE\n    \&quot;\&quot;\&quot;\n    # copy so the injected claim doesn't mutate the input claims\n    # this is a temporary hack to allow for graceful deprecation of tokens,\n    # ensuring that the library can still handle decrypting tokens issued\n    # before the implementation of the fix\n    claims = deepcopy(claims)\n    assert _TEMP_VER_KEY not in claims\n    claims[_TEMP_VER_KEY] = _TEMP_VER\n\n    header = dict((add_header or {}).items() + [\n        ('enc', enc), ('alg', alg)])\n\n    # promote the temp key to the header\n    assert _TEMP_VER_KEY not in header\n    header[_TEMP_VER_KEY] = claims[_TEMP_VER_KEY]\n\n    plaintext = json_encode(claims)\n\n    # compress (if required)\n    if compression is not None:\n        header['zip'] = compression\n        try:\n            (compress, _) = COMPRESSION[compression]\n        except KeyError:\n            raise Error(\n                'Unsupported compression algorithm: {}'.format(compression))\n        plaintext = compress(plaintext)\n\n    # body encryption/hash\n    ((cipher, _), key_size), ((hash_fn, _), hash_mod) = JWA[enc]\n    iv = rng(AES.block_size)\n    encryption_key = rng(hash_mod.digest_size)\n\n    ciphertext = cipher(plaintext, encryption_key[-hash_mod.digest_size/2:], iv)\n    hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata),\n            encryption_key[:-hash_mod.digest_size/2], hash_mod)\n\n    # cek encryption\n    (cipher, _), _ = JWA[alg]\n    encryption_key_ciphertext = cipher(encryption_key, jwk)\n\n    return JWE(*map(b64encode_url,\n            (json_encode(header),\n            encryption_key_ciphertext,\n            iv,\n            ciphertext,\n            auth_tag(hash))))\n\n\ndef decrypt(jwe, jwk, adata='', validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Decrypts a deserialized :class:`~jose.JWE`\n\n    :param jwe: An instance of :class:`~jose.JWE`\n    :param jwk: A `dict` representing the JWK required to decrypt the content\n                of the :class:`~jose.JWE`.\n    :param adata: Arbitrary string data used during encryption for additional\n                  authentication.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, encryption_key_ciphertext, iv, ciphertext, tag = map(\n        b64decode_url, jwe)\n    header = json_decode(header)\n\n    # decrypt cek\n    (_, decipher), _ = JWA[header['alg']]\n    encryption_key = decipher(encryption_key_ciphertext, jwk)\n\n    # decrypt body\n    ((_, decipher), _), ((hash_fn, _), mod) = JWA[header['enc']]\n\n    version = header.get(_TEMP_VER_KEY)\n    if version:\n        plaintext = decipher(ciphertext, encryption_key[-mod.digest_size/2:], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n                encryption_key[:-mod.digest_size/2], mod=mod)\n    else:\n        plaintext = decipher(ciphertext, encryption_key[:-mod.digest_size], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n            encryption_key[-mod.digest_size:], mod=mod)\n\n    if not const_compare(auth_tag(hash), tag):\n        raise Error('Mismatched authentication tags')\n\n    if 'zip' in header:\n        try:\n            (_, decompress) = COMPRESSION[header['zip']]\n        except KeyError:\n            raise Error('Unsupported compression algorithm: {}'.format(\n                header['zip']))\n\n        plaintext = decompress(plaintext)\n\n    claims = json_decode(plaintext)\n    try:\n        del claims[_TEMP_VER_KEY]\n    except KeyError:\n        # expected when decrypting legacy tokens\n        pass\n\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef sign(claims, jwk, add_header=None, alg='HS256'):\n    \&quot;\&quot;\&quot; Signs the given claims and produces a :class:`~jose.JWS`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWS`.\n    :param jwk: A `dict` representing the JWK to be used for signing of the\n                :class:`~jose.JWS`. This parameter is algorithm-specific.\n    :parameter add_header: Additional items to be added to the header.\n                           Additional headers *will* be authenticated.\n    :parameter alg: The algorithm to use to produce the signature.\n    :rtype: :class:`~jose.JWS`\n    \&quot;\&quot;\&quot;\n    (hash_fn, _), mod = JWA[alg]\n\n    header = dict((add_header or {}).items() + [('alg', alg)])\n    header, payload = map(b64encode_url, map(json_encode, (header, claims)))\n\n    sig = b64encode_url(hash_fn(_jws_hash_str(header, payload), jwk['k'],\n        mod=mod))\n\n    return JWS(header, payload, sig)\n\n\ndef verify(jws, jwk, alg, validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Verifies the given :class:`~jose.JWS`\n\n    :param jws: The :class:`~jose.JWS` to be verified.\n    :param jwk: A `dict` representing the JWK to use for verification. This\n                parameter is algorithm-specific.\n    :param alg: The algorithm to verify the signature with.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, payload, sig = map(b64decode_url, jws)\n    header = json_decode(header)\n    if alg != header['alg']:\n        raise Error('Invalid algorithm')\n\n    (_, verify_fn), mod = JWA[header['alg']]\n\n    if not verify_fn(_jws_hash_str(jws.header, jws.payload),\n            jwk['k'], sig, mod=mod):\n        raise Error('Mismatched signatures')\n\n    claims = json_decode(b64decode_url(jws.payload))\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef b64decode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    istr = encode_safe(istr)\n    try:\n        return urlsafe_b64decode(istr + '=' * (4 - (len(istr) % 4)))\n    except TypeError as e:\n        raise Error('Unable to decode base64: %s' % (e))\n\n\ndef b64encode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    return urlsafe_b64encode(encode_safe(istr)).rstrip('=')\n\n\ndef encode_safe(istr, encoding='utf8'):\n    try:\n        return istr.encode(encoding)\n    except UnicodeDecodeError:\n        # this will fail if istr is already encoded\n        pass\n    return istr\n\n\ndef auth_tag(hmac):\n    # http://tools.ietf.org/html/\n    # draft-ietf-oauth-json-web-token-19#section-4.1.4\n    return hmac[:len(hmac) // 2]\n\n\ndef pad_pkcs7(s):\n    sz = AES.block_size - (len(s) % AES.block_size)\n    return s + (chr(sz) * sz)\n\n\ndef unpad_pkcs7(s):\n    return s[:-ord(s[-1])]\n\n\ndef encrypt_oaep(plaintext, jwk):\n    return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).encrypt(plaintext)\n\n\ndef decrypt_oaep(ciphertext, jwk):\n    try:\n        return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).decrypt(ciphertext)\n    except ValueError as e:\n        raise Error(e.args[0])\n\n\ndef hmac_sign(s, key, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n    return hmac.digest()\n\n\ndef hmac_verify(s, key, sig, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n\n    if not const_compare(hmac.digest(), sig):\n        return False\n\n    return True\n\n\ndef rsa_sign(s, key, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).sign(hash)\n\n\ndef rsa_verify(s, key, sig, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).verify(hash, sig)\n\n\ndef encrypt_aescbc(plaintext, key, iv):\n    plaintext = pad_pkcs7(plaintext)\n    return AES.new(key, AES.MODE_CBC, iv).encrypt(plaintext)\n\n\ndef decrypt_aescbc(ciphertext, key, iv):\n    return unpad_pkcs7(AES.new(key, AES.MODE_CBC, iv).decrypt(ciphertext))\n\n\ndef const_compare(stra, strb):\n    if len(stra) != len(strb):\n        return False\n\n    res = 0\n    for a, b in zip(stra, strb):\n        res |= ord(a) ^ ord(b)\n    return res == 0\n\n\nclass _JWA(object):\n    \&quot;\&quot;\&quot; Represents the implemented algorithms\n\n    A big TODO list can be found here:\n    http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-24\n    \&quot;\&quot;\&quot;\n    _impl = {\n        'HS256': ((hmac_sign, hmac_verify), SHA256),\n        'HS384': ((hmac_sign, hmac_verify), SHA384),\n        'HS512': ((hmac_sign, hmac_verify), SHA512),\n        'RS256': ((rsa_sign, rsa_verify), SHA256),\n        'RS384': ((rsa_sign, rsa_verify), SHA384),\n        'RS512': ((rsa_sign, rsa_verify), SHA512),\n        'RSA-OAEP': ((encrypt_oaep, decrypt_oaep), 2048),\n\n        'A128CBC': ((encrypt_aescbc, decrypt_aescbc), 128),\n        'A192CBC': ((encrypt_aescbc, decrypt_aescbc), 192),\n        'A256CBC': ((encrypt_aescbc, decrypt_aescbc), 256),\n    }\n\n    def __getitem__(self, key):\n        \&quot;\&quot;\&quot; Derive implementation(s) from key\n        \&quot;\&quot;\&quot;\n        if key in self._impl:\n            return self._impl[key]\n\n        enc, hash = self._compound_from_key(key)\n        return self._impl[enc], self._impl[hash]\n\n    def _compound_from_key(self, key):\n        try:\n            enc, hash = key.split('+')\n            return enc, hash\n        except ValueError:\n            pass\n\n        try:\n            enc, hash = key.split('-')\n            return enc, hash\n        except ValueError:\n            pass\n\n        raise Error('Unsupported algorithm: {}'.format(key))\n\n\nJWA = _JWA()\n\n\nCOMPRESSION = {\n    'DEF': (zlib.compress, zlib.decompress),\n}\n\n\ndef _format_timestamp(ts):\n    dt = datetime.datetime.utcfromtimestamp(ts)\n    return dt.isoformat() + 'Z'\n\n\ndef _check_expiration_time(now, expiration_time):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if now &gt;= expiration_time:\n        raise Expired('Token expired at {}'.format(\n            _format_timestamp(expiration_time))\n        )\n\n\ndef _check_not_before(now, not_before):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if not_before &gt; now:\n        raise NotYetValid('Token not valid until {}'.format(\n            _format_timestamp(not_before))\n        )\n\n\ndef _validate(claims, validate_claims, expiry_seconds):\n    \&quot;\&quot;\&quot; Validate expiry related claims.\n\n    If validate_claims is False, do nothing.\n\n    Otherwise, validate the exp and nbf claims if they are present, and\n    validate the iat claim if expiry_seconds is provided.\n    \&quot;\&quot;\&quot;\n    if not validate_claims:\n        return\n\n    now = time()\n\n    # TODO: implement support for clock skew\n\n    # The exp (expiration time) claim identifies the expiration time on or\n    # after which the JWT MUST NOT be accepted for processing. The\n    # processing of the exp claim requires that the current date/time MUST\n    # be before the expiration date/time listed in the exp claim.\n    try:\n        expiration_time = claims[CLAIM_EXPIRATION_TIME]\n    except KeyError:\n        pass\n    else:\n        _check_expiration_time(now, expiration_time)\n\n    # The iat (issued at) claim identifies the time at which the JWT was\n    # issued. This claim can be used to determine the age of the JWT.\n    # If expiry_seconds is provided, and the iat claims is present,\n    # determine the age of the token and check if it has expired.\n    try:\n        issued_at = claims[CLAIM_ISSUED_AT]\n    except KeyError:\n        pass\n    else:\n        if expiry_seconds is not None:\n            _check_expiration_time(now, issued_at + expiry_seconds)\n\n    # The nbf (not before) claim identifies the time before which the JWT\n    # MUST NOT be accepted for processing. The processing of the nbf claim\n    # requires that the current date/time MUST be after or equal to the\n    # not-before date/time listed in the nbf claim.\n    try:\n        not_before = claims[CLAIM_NOT_BEFORE]\n    except KeyError:\n        pass\n    else:\n        _check_not_before(now, not_before)\n\n\ndef _jwe_hash_str(ciphertext, iv, adata='', version=_TEMP_VER):\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-algorithms-24#section-5.2.2.1\n    # Both tokens without version and with version 1 should be ignored in\n    # the future as they use incorrect hashing. The version parameter\n    # should also be removed.\n    if not version:\n        return '.'.join((adata, iv, ciphertext, str(len(adata))))\n    elif version == 1:\n        return '.'.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n    return ''.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n\n\ndef _jws_hash_str(header, claims):\n    return '.'.join((header, claims))\n\n\ndef cli_decrypt(jwt, key):\n    print decrypt(deserialize_compact(jwt), {'k':key},\n        validate_claims=False)\n\n\ndef _cli():\n    import inspect\n    import sys\n\n    from argparse import ArgumentParser\n    from copy import copy\n\n    parser = ArgumentParser()\n    subparsers = parser.add_subparsers(dest='subparser_name')\n\n    commands = {\n        'decrypt': cli_decrypt,\n    }\n    for k, fn in commands.items():\n        p = subparsers.add_parser(k)\n        for arg in inspect.getargspec(fn).args:\n            p.add_argument(arg)\n\n    args = parser.parse_args()\n    handler = commands[args.subparser_name]\n    handler_args = [getattr(args, k) for k in inspect.getargspec(\n        handler).args]\n    handler(*handler_args)\n&quot;}]},&quot;createdAt&quot;:1751746600680,&quot;isInternal&quot;:false,&quot;rawContent&quot;:{&quot;type&quot;:&quot;doc&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;stills&quot;}]}]}},{&quot;id&quot;:&quot;3f0d745b-90c7-45cc-92db-d63c6093aae2&quot;,&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;If you have already installed `pycryptodome` and are still encountering the `ModuleNotFoundError: No module named 'Crypto'`, it might be due to a few potential issues:\n\n1. **Installation in the Wrong Environment**: Ensure that `pycryptodome` is installed in the correct virtual environment. Activate your virtual environment and then run the installation command:\n\n   ```bash\n   pip install pycryptodome\n   ```\n\n2. **Conflicting Packages**: There might be a conflict with another package named `crypto` or `pycrypto`. If you have `pycrypto` installed, it can cause conflicts because it also uses the `Crypto` namespace. You should uninstall `pycrypto` if it's installed:\n\n   ```bash\n   pip uninstall pycrypto\n   ```\n\n3. **Verify Installation**: After installing `pycryptodome`, verify that it is installed correctly by running:\n\n   ```bash\n   pip show pycryptodome\n   ```\n\n   This should display information about the package if it is installed correctly.\n\n4. **Check Python Path**: Ensure that your Python path is set correctly and that it includes the site-packages directory of your virtual environment. You can check this by running:\n\n   ```python\n   import sys\n   print(sys.path)\n   ```\n\n   Make sure the path to your virtual environment's site-packages is included.\n\n5. **Correct Import Statement**: Ensure that the import statement in your code is correct. It should be:\n\n   ```python\n   from Crypto.Hash import HMAC, SHA256, SHA384, SHA512\n   ```\n\nIf you've checked all these points and the issue persists, try reinstalling `pycryptodome`:\n\n```bash\npip uninstall pycryptodome\npip install pycryptodome\n```\n\nThese steps should help resolve the `ModuleNotFoundError` for the `Crypto` module.&quot;}],&quot;context&quot;:{&quot;currentFile&quot;:{&quot;path&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;],&quot;content&quot;:&quot;import logging\nlogger = logging.getLogger(__name__)\n\ntry:\n    from cjson import encode as json_encode, decode as json_decode\nexcept ImportError:  # pragma: nocover\n    logger.warn('cjson not found, falling back to stdlib json')\n    from json import loads as json_decode, dumps as json_encode\n\nimport zlib\nimport datetime\n\nfrom base64 import urlsafe_b64encode, urlsafe_b64decode\nfrom collections import namedtuple\nfrom copy import deepcopy\nfrom time import time\nfrom struct import pack\n\nfrom Crypto.Hash import HMAC, SHA256, SHA384, SHA512\nfrom Crypto.Cipher import PKCS1_OAEP, AES\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Random import get_random_bytes\nfrom Crypto.Signature import PKCS1_v1_5 as PKCS1_v1_5_SIG\n\n\n__all__ = ['encrypt', 'decrypt', 'sign', 'verify']\n\n\n# XXX: The attribute order is IMPORTANT in the following namedtuple\n# definitions. DO NOT change them, unless you really know what you're doing.\n\nJWE = namedtuple('JWE',\n    'header '\n    'cek '\n    'iv '\n    'ciphertext '\n    'tag ')\n\nJWS = namedtuple('JWS',\n        'header '\n        'payload '\n        'signature ')\n\nJWT = namedtuple('JWT',\n        'header '\n        'claims ')\n\n\nCLAIM_ISSUER = 'iss'\nCLAIM_SUBJECT = 'sub'\nCLAIM_AUDIENCE = 'aud'\nCLAIM_EXPIRATION_TIME = 'exp'\nCLAIM_NOT_BEFORE = 'nbf'\nCLAIM_ISSUED_AT = 'iat'\nCLAIM_JWT_ID = 'jti'\n\n# these are temporary to allow graceful deprecation of legacy encrypted tokens.\n# these will be removed in v1.0\n_TEMP_VER_KEY = '__v'\n_TEMP_VER = 2\n\n\nclass Error(Exception):\n    \&quot;\&quot;\&quot; The base error type raised by jose\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass Expired(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation if a JWT has expired\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass NotYetValid(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation is a JWT is not yet valid\n    \&quot;\&quot;\&quot;\n    pass\n\n\ndef serialize_compact(jwt):\n    \&quot;\&quot;\&quot; Compact serialization of a :class:`~jose.JWE` or :class:`~jose.JWS`\n\n    :rtype: str\n    :returns: A string, representing the compact serialization of a\n              :class:`~jose.JWE` or :class:`~jose.JWS`.\n    \&quot;\&quot;\&quot;\n    return '.'.join(jwt)\n\n\ndef deserialize_compact(jwt):\n    \&quot;\&quot;\&quot; Deserialization of a compact representation of a :class:`~jwt.JWE`\n\n    :param jwt: The serialized JWT to deserialize.\n    :rtype: :class:`~jose.JWT`.\n    :raises: :class:`~jose.Error` if the JWT is malformed\n    \&quot;\&quot;\&quot;\n    parts = jwt.split('.')\n\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-encryption-23#section-9\n    if len(parts) == 3:\n        token_type = JWS\n    elif len(parts) == 5:\n        token_type = JWE\n    else:\n        raise Error('Malformed JWT')\n\n    return token_type(*parts)\n\n\ndef encrypt(claims, jwk, adata='', add_header=None, alg='RSA-OAEP',\n        enc='A128CBC-HS256', rng=get_random_bytes, compression=None):\n    \&quot;\&quot;\&quot; Encrypts the given claims and produces a :class:`~jose.JWE`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWE`.\n    :param jwk: A `dict` representing the JWK to be used for encryption of\n                the CEK. This parameter is algorithm-specific.\n    :param adata: Arbitrary string data to add to the authentication\n                  (i.e. HMAC). The same data must be provided during\n                  decryption.\n    :param add_header: Additional items to be added to the header. Additional\n                       headers *will* be authenticated.\n    :param alg: The algorithm to use for CEK encryption\n    :param enc: The algorithm to use for claims encryption\n    :param rng: Random number generator. A string of random bytes is expected\n                as output.\n    :param compression: The compression algorithm to use. Currently supports\n                `'DEF'`.\n    :rtype: :class:`~jose.JWE`\n    :raises: :class:`~jose.Error` if there is an error producing the JWE\n    \&quot;\&quot;\&quot;\n    # copy so the injected claim doesn't mutate the input claims\n    # this is a temporary hack to allow for graceful deprecation of tokens,\n    # ensuring that the library can still handle decrypting tokens issued\n    # before the implementation of the fix\n    claims = deepcopy(claims)\n    assert _TEMP_VER_KEY not in claims\n    claims[_TEMP_VER_KEY] = _TEMP_VER\n\n    header = dict((add_header or {}).items() + [\n        ('enc', enc), ('alg', alg)])\n\n    # promote the temp key to the header\n    assert _TEMP_VER_KEY not in header\n    header[_TEMP_VER_KEY] = claims[_TEMP_VER_KEY]\n\n    plaintext = json_encode(claims)\n\n    # compress (if required)\n    if compression is not None:\n        header['zip'] = compression\n        try:\n            (compress, _) = COMPRESSION[compression]\n        except KeyError:\n            raise Error(\n                'Unsupported compression algorithm: {}'.format(compression))\n        plaintext = compress(plaintext)\n\n    # body encryption/hash\n    ((cipher, _), key_size), ((hash_fn, _), hash_mod) = JWA[enc]\n    iv = rng(AES.block_size)\n    encryption_key = rng(hash_mod.digest_size)\n\n    ciphertext = cipher(plaintext, encryption_key[-hash_mod.digest_size/2:], iv)\n    hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata),\n            encryption_key[:-hash_mod.digest_size/2], hash_mod)\n\n    # cek encryption\n    (cipher, _), _ = JWA[alg]\n    encryption_key_ciphertext = cipher(encryption_key, jwk)\n\n    return JWE(*map(b64encode_url,\n            (json_encode(header),\n            encryption_key_ciphertext,\n            iv,\n            ciphertext,\n            auth_tag(hash))))\n\n\ndef decrypt(jwe, jwk, adata='', validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Decrypts a deserialized :class:`~jose.JWE`\n\n    :param jwe: An instance of :class:`~jose.JWE`\n    :param jwk: A `dict` representing the JWK required to decrypt the content\n                of the :class:`~jose.JWE`.\n    :param adata: Arbitrary string data used during encryption for additional\n                  authentication.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, encryption_key_ciphertext, iv, ciphertext, tag = map(\n        b64decode_url, jwe)\n    header = json_decode(header)\n\n    # decrypt cek\n    (_, decipher), _ = JWA[header['alg']]\n    encryption_key = decipher(encryption_key_ciphertext, jwk)\n\n    # decrypt body\n    ((_, decipher), _), ((hash_fn, _), mod) = JWA[header['enc']]\n\n    version = header.get(_TEMP_VER_KEY)\n    if version:\n        plaintext = decipher(ciphertext, encryption_key[-mod.digest_size/2:], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n                encryption_key[:-mod.digest_size/2], mod=mod)\n    else:\n        plaintext = decipher(ciphertext, encryption_key[:-mod.digest_size], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n            encryption_key[-mod.digest_size:], mod=mod)\n\n    if not const_compare(auth_tag(hash), tag):\n        raise Error('Mismatched authentication tags')\n\n    if 'zip' in header:\n        try:\n            (_, decompress) = COMPRESSION[header['zip']]\n        except KeyError:\n            raise Error('Unsupported compression algorithm: {}'.format(\n                header['zip']))\n\n        plaintext = decompress(plaintext)\n\n    claims = json_decode(plaintext)\n    try:\n        del claims[_TEMP_VER_KEY]\n    except KeyError:\n        # expected when decrypting legacy tokens\n        pass\n\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef sign(claims, jwk, add_header=None, alg='HS256'):\n    \&quot;\&quot;\&quot; Signs the given claims and produces a :class:`~jose.JWS`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWS`.\n    :param jwk: A `dict` representing the JWK to be used for signing of the\n                :class:`~jose.JWS`. This parameter is algorithm-specific.\n    :parameter add_header: Additional items to be added to the header.\n                           Additional headers *will* be authenticated.\n    :parameter alg: The algorithm to use to produce the signature.\n    :rtype: :class:`~jose.JWS`\n    \&quot;\&quot;\&quot;\n    (hash_fn, _), mod = JWA[alg]\n\n    header = dict((add_header or {}).items() + [('alg', alg)])\n    header, payload = map(b64encode_url, map(json_encode, (header, claims)))\n\n    sig = b64encode_url(hash_fn(_jws_hash_str(header, payload), jwk['k'],\n        mod=mod))\n\n    return JWS(header, payload, sig)\n\n\ndef verify(jws, jwk, alg, validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Verifies the given :class:`~jose.JWS`\n\n    :param jws: The :class:`~jose.JWS` to be verified.\n    :param jwk: A `dict` representing the JWK to use for verification. This\n                parameter is algorithm-specific.\n    :param alg: The algorithm to verify the signature with.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, payload, sig = map(b64decode_url, jws)\n    header = json_decode(header)\n    if alg != header['alg']:\n        raise Error('Invalid algorithm')\n\n    (_, verify_fn), mod = JWA[header['alg']]\n\n    if not verify_fn(_jws_hash_str(jws.header, jws.payload),\n            jwk['k'], sig, mod=mod):\n        raise Error('Mismatched signatures')\n\n    claims = json_decode(b64decode_url(jws.payload))\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef b64decode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    istr = encode_safe(istr)\n    try:\n        return urlsafe_b64decode(istr + '=' * (4 - (len(istr) % 4)))\n    except TypeError as e:\n        raise Error('Unable to decode base64: %s' % (e))\n\n\ndef b64encode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    return urlsafe_b64encode(encode_safe(istr)).rstrip('=')\n\n\ndef encode_safe(istr, encoding='utf8'):\n    try:\n        return istr.encode(encoding)\n    except UnicodeDecodeError:\n        # this will fail if istr is already encoded\n        pass\n    return istr\n\n\ndef auth_tag(hmac):\n    # http://tools.ietf.org/html/\n    # draft-ietf-oauth-json-web-token-19#section-4.1.4\n    return hmac[:len(hmac) // 2]\n\n\ndef pad_pkcs7(s):\n    sz = AES.block_size - (len(s) % AES.block_size)\n    return s + (chr(sz) * sz)\n\n\ndef unpad_pkcs7(s):\n    return s[:-ord(s[-1])]\n\n\ndef encrypt_oaep(plaintext, jwk):\n    return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).encrypt(plaintext)\n\n\ndef decrypt_oaep(ciphertext, jwk):\n    try:\n        return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).decrypt(ciphertext)\n    except ValueError as e:\n        raise Error(e.args[0])\n\n\ndef hmac_sign(s, key, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n    return hmac.digest()\n\n\ndef hmac_verify(s, key, sig, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n\n    if not const_compare(hmac.digest(), sig):\n        return False\n\n    return True\n\n\ndef rsa_sign(s, key, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).sign(hash)\n\n\ndef rsa_verify(s, key, sig, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).verify(hash, sig)\n\n\ndef encrypt_aescbc(plaintext, key, iv):\n    plaintext = pad_pkcs7(plaintext)\n    return AES.new(key, AES.MODE_CBC, iv).encrypt(plaintext)\n\n\ndef decrypt_aescbc(ciphertext, key, iv):\n    return unpad_pkcs7(AES.new(key, AES.MODE_CBC, iv).decrypt(ciphertext))\n\n\ndef const_compare(stra, strb):\n    if len(stra) != len(strb):\n        return False\n\n    res = 0\n    for a, b in zip(stra, strb):\n        res |= ord(a) ^ ord(b)\n    return res == 0\n\n\nclass _JWA(object):\n    \&quot;\&quot;\&quot; Represents the implemented algorithms\n\n    A big TODO list can be found here:\n    http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-24\n    \&quot;\&quot;\&quot;\n    _impl = {\n        'HS256': ((hmac_sign, hmac_verify), SHA256),\n        'HS384': ((hmac_sign, hmac_verify), SHA384),\n        'HS512': ((hmac_sign, hmac_verify), SHA512),\n        'RS256': ((rsa_sign, rsa_verify), SHA256),\n        'RS384': ((rsa_sign, rsa_verify), SHA384),\n        'RS512': ((rsa_sign, rsa_verify), SHA512),\n        'RSA-OAEP': ((encrypt_oaep, decrypt_oaep), 2048),\n\n        'A128CBC': ((encrypt_aescbc, decrypt_aescbc), 128),\n        'A192CBC': ((encrypt_aescbc, decrypt_aescbc), 192),\n        'A256CBC': ((encrypt_aescbc, decrypt_aescbc), 256),\n    }\n\n    def __getitem__(self, key):\n        \&quot;\&quot;\&quot; Derive implementation(s) from key\n        \&quot;\&quot;\&quot;\n        if key in self._impl:\n            return self._impl[key]\n\n        enc, hash = self._compound_from_key(key)\n        return self._impl[enc], self._impl[hash]\n\n    def _compound_from_key(self, key):\n        try:\n            enc, hash = key.split('+')\n            return enc, hash\n        except ValueError:\n            pass\n\n        try:\n            enc, hash = key.split('-')\n            return enc, hash\n        except ValueError:\n            pass\n\n        raise Error('Unsupported algorithm: {}'.format(key))\n\n\nJWA = _JWA()\n\n\nCOMPRESSION = {\n    'DEF': (zlib.compress, zlib.decompress),\n}\n\n\ndef _format_timestamp(ts):\n    dt = datetime.datetime.utcfromtimestamp(ts)\n    return dt.isoformat() + 'Z'\n\n\ndef _check_expiration_time(now, expiration_time):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if now &gt;= expiration_time:\n        raise Expired('Token expired at {}'.format(\n            _format_timestamp(expiration_time))\n        )\n\n\ndef _check_not_before(now, not_before):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if not_before &gt; now:\n        raise NotYetValid('Token not valid until {}'.format(\n            _format_timestamp(not_before))\n        )\n\n\ndef _validate(claims, validate_claims, expiry_seconds):\n    \&quot;\&quot;\&quot; Validate expiry related claims.\n\n    If validate_claims is False, do nothing.\n\n    Otherwise, validate the exp and nbf claims if they are present, and\n    validate the iat claim if expiry_seconds is provided.\n    \&quot;\&quot;\&quot;\n    if not validate_claims:\n        return\n\n    now = time()\n\n    # TODO: implement support for clock skew\n\n    # The exp (expiration time) claim identifies the expiration time on or\n    # after which the JWT MUST NOT be accepted for processing. The\n    # processing of the exp claim requires that the current date/time MUST\n    # be before the expiration date/time listed in the exp claim.\n    try:\n        expiration_time = claims[CLAIM_EXPIRATION_TIME]\n    except KeyError:\n        pass\n    else:\n        _check_expiration_time(now, expiration_time)\n\n    # The iat (issued at) claim identifies the time at which the JWT was\n    # issued. This claim can be used to determine the age of the JWT.\n    # If expiry_seconds is provided, and the iat claims is present,\n    # determine the age of the token and check if it has expired.\n    try:\n        issued_at = claims[CLAIM_ISSUED_AT]\n    except KeyError:\n        pass\n    else:\n        if expiry_seconds is not None:\n            _check_expiration_time(now, issued_at + expiry_seconds)\n\n    # The nbf (not before) claim identifies the time before which the JWT\n    # MUST NOT be accepted for processing. The processing of the nbf claim\n    # requires that the current date/time MUST be after or equal to the\n    # not-before date/time listed in the nbf claim.\n    try:\n        not_before = claims[CLAIM_NOT_BEFORE]\n    except KeyError:\n        pass\n    else:\n        _check_not_before(now, not_before)\n\n\ndef _jwe_hash_str(ciphertext, iv, adata='', version=_TEMP_VER):\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-algorithms-24#section-5.2.2.1\n    # Both tokens without version and with version 1 should be ignored in\n    # the future as they use incorrect hashing. The version parameter\n    # should also be removed.\n    if not version:\n        return '.'.join((adata, iv, ciphertext, str(len(adata))))\n    elif version == 1:\n        return '.'.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n    return ''.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n\n\ndef _jws_hash_str(header, claims):\n    return '.'.join((header, claims))\n\n\ndef cli_decrypt(jwt, key):\n    print decrypt(deserialize_compact(jwt), {'k':key},\n        validate_claims=False)\n\n\ndef _cli():\n    import inspect\n    import sys\n\n    from argparse import ArgumentParser\n    from copy import copy\n\n    parser = ArgumentParser()\n    subparsers = parser.add_subparsers(dest='subparser_name')\n\n    commands = {\n        'decrypt': cli_decrypt,\n    }\n    for k, fn in commands.items():\n        p = subparsers.add_parser(k)\n        for arg in inspect.getargspec(fn).args:\n            p.add_argument(arg)\n\n    args = parser.parse_args()\n    handler = commands[args.subparser_name]\n    handler_args = [getattr(args, k) for k in inspect.getargspec(\n        handler).args]\n    handler(*handler_args)\n&quot;},&quot;codebaseEnabled&quot;:true,&quot;ragFiles&quot;:[{&quot;path&quot;:&quot;agents\\job_creator_agent.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\agents\\job_creator_agent.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;schemas\\auth.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\schemas\\auth.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\config.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\config.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;core\\database.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\database.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;models\\models.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\models\\models.py&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;.gitignore&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.gitignore&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;alembic\\alembic.ini&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\alembic\\alembic.ini&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;README.md&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\README.md&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;pyproject.toml&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\pyproject.toml&quot;,&quot;sources&quot;:[]},{&quot;path&quot;:&quot;models/models.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\models\\models.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;core/security.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\core\\security.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;models/organization.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\models\\organization.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;schemas/auth.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\schemas\\auth.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;schemas/schemas.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\schemas\\schemas.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;services/auth_service.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\services\\auth_service.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;__init__.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\__init__.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;main.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\main.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;.env&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.env&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]},{&quot;path&quot;:&quot;.venv/Lib/site-packages/jose.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;]}],&quot;rerankedFiles&quot;:[],&quot;usedFilePaths&quot;:[{&quot;path&quot;:&quot;.venv\\Lib\\site-packages\\jose.py&quot;,&quot;fsPath&quot;:&quot;C:\\Users\\kaell\\Desktop\\Carreira\\Projetos\\Aiagent\\backend\\.venv\\Lib\\site-packages\\jose.py&quot;,&quot;sources&quot;:[&quot;opened_tab&quot;],&quot;content&quot;:&quot;import logging\nlogger = logging.getLogger(__name__)\n\ntry:\n    from cjson import encode as json_encode, decode as json_decode\nexcept ImportError:  # pragma: nocover\n    logger.warn('cjson not found, falling back to stdlib json')\n    from json import loads as json_decode, dumps as json_encode\n\nimport zlib\nimport datetime\n\nfrom base64 import urlsafe_b64encode, urlsafe_b64decode\nfrom collections import namedtuple\nfrom copy import deepcopy\nfrom time import time\nfrom struct import pack\n\nfrom Crypto.Hash import HMAC, SHA256, SHA384, SHA512\nfrom Crypto.Cipher import PKCS1_OAEP, AES\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Random import get_random_bytes\nfrom Crypto.Signature import PKCS1_v1_5 as PKCS1_v1_5_SIG\n\n\n__all__ = ['encrypt', 'decrypt', 'sign', 'verify']\n\n\n# XXX: The attribute order is IMPORTANT in the following namedtuple\n# definitions. DO NOT change them, unless you really know what you're doing.\n\nJWE = namedtuple('JWE',\n    'header '\n    'cek '\n    'iv '\n    'ciphertext '\n    'tag ')\n\nJWS = namedtuple('JWS',\n        'header '\n        'payload '\n        'signature ')\n\nJWT = namedtuple('JWT',\n        'header '\n        'claims ')\n\n\nCLAIM_ISSUER = 'iss'\nCLAIM_SUBJECT = 'sub'\nCLAIM_AUDIENCE = 'aud'\nCLAIM_EXPIRATION_TIME = 'exp'\nCLAIM_NOT_BEFORE = 'nbf'\nCLAIM_ISSUED_AT = 'iat'\nCLAIM_JWT_ID = 'jti'\n\n# these are temporary to allow graceful deprecation of legacy encrypted tokens.\n# these will be removed in v1.0\n_TEMP_VER_KEY = '__v'\n_TEMP_VER = 2\n\n\nclass Error(Exception):\n    \&quot;\&quot;\&quot; The base error type raised by jose\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass Expired(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation if a JWT has expired\n    \&quot;\&quot;\&quot;\n    pass\n\n\nclass NotYetValid(Error):\n    \&quot;\&quot;\&quot; Raised during claims validation is a JWT is not yet valid\n    \&quot;\&quot;\&quot;\n    pass\n\n\ndef serialize_compact(jwt):\n    \&quot;\&quot;\&quot; Compact serialization of a :class:`~jose.JWE` or :class:`~jose.JWS`\n\n    :rtype: str\n    :returns: A string, representing the compact serialization of a\n              :class:`~jose.JWE` or :class:`~jose.JWS`.\n    \&quot;\&quot;\&quot;\n    return '.'.join(jwt)\n\n\ndef deserialize_compact(jwt):\n    \&quot;\&quot;\&quot; Deserialization of a compact representation of a :class:`~jwt.JWE`\n\n    :param jwt: The serialized JWT to deserialize.\n    :rtype: :class:`~jose.JWT`.\n    :raises: :class:`~jose.Error` if the JWT is malformed\n    \&quot;\&quot;\&quot;\n    parts = jwt.split('.')\n\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-encryption-23#section-9\n    if len(parts) == 3:\n        token_type = JWS\n    elif len(parts) == 5:\n        token_type = JWE\n    else:\n        raise Error('Malformed JWT')\n\n    return token_type(*parts)\n\n\ndef encrypt(claims, jwk, adata='', add_header=None, alg='RSA-OAEP',\n        enc='A128CBC-HS256', rng=get_random_bytes, compression=None):\n    \&quot;\&quot;\&quot; Encrypts the given claims and produces a :class:`~jose.JWE`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWE`.\n    :param jwk: A `dict` representing the JWK to be used for encryption of\n                the CEK. This parameter is algorithm-specific.\n    :param adata: Arbitrary string data to add to the authentication\n                  (i.e. HMAC). The same data must be provided during\n                  decryption.\n    :param add_header: Additional items to be added to the header. Additional\n                       headers *will* be authenticated.\n    :param alg: The algorithm to use for CEK encryption\n    :param enc: The algorithm to use for claims encryption\n    :param rng: Random number generator. A string of random bytes is expected\n                as output.\n    :param compression: The compression algorithm to use. Currently supports\n                `'DEF'`.\n    :rtype: :class:`~jose.JWE`\n    :raises: :class:`~jose.Error` if there is an error producing the JWE\n    \&quot;\&quot;\&quot;\n    # copy so the injected claim doesn't mutate the input claims\n    # this is a temporary hack to allow for graceful deprecation of tokens,\n    # ensuring that the library can still handle decrypting tokens issued\n    # before the implementation of the fix\n    claims = deepcopy(claims)\n    assert _TEMP_VER_KEY not in claims\n    claims[_TEMP_VER_KEY] = _TEMP_VER\n\n    header = dict((add_header or {}).items() + [\n        ('enc', enc), ('alg', alg)])\n\n    # promote the temp key to the header\n    assert _TEMP_VER_KEY not in header\n    header[_TEMP_VER_KEY] = claims[_TEMP_VER_KEY]\n\n    plaintext = json_encode(claims)\n\n    # compress (if required)\n    if compression is not None:\n        header['zip'] = compression\n        try:\n            (compress, _) = COMPRESSION[compression]\n        except KeyError:\n            raise Error(\n                'Unsupported compression algorithm: {}'.format(compression))\n        plaintext = compress(plaintext)\n\n    # body encryption/hash\n    ((cipher, _), key_size), ((hash_fn, _), hash_mod) = JWA[enc]\n    iv = rng(AES.block_size)\n    encryption_key = rng(hash_mod.digest_size)\n\n    ciphertext = cipher(plaintext, encryption_key[-hash_mod.digest_size/2:], iv)\n    hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata),\n            encryption_key[:-hash_mod.digest_size/2], hash_mod)\n\n    # cek encryption\n    (cipher, _), _ = JWA[alg]\n    encryption_key_ciphertext = cipher(encryption_key, jwk)\n\n    return JWE(*map(b64encode_url,\n            (json_encode(header),\n            encryption_key_ciphertext,\n            iv,\n            ciphertext,\n            auth_tag(hash))))\n\n\ndef decrypt(jwe, jwk, adata='', validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Decrypts a deserialized :class:`~jose.JWE`\n\n    :param jwe: An instance of :class:`~jose.JWE`\n    :param jwk: A `dict` representing the JWK required to decrypt the content\n                of the :class:`~jose.JWE`.\n    :param adata: Arbitrary string data used during encryption for additional\n                  authentication.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, encryption_key_ciphertext, iv, ciphertext, tag = map(\n        b64decode_url, jwe)\n    header = json_decode(header)\n\n    # decrypt cek\n    (_, decipher), _ = JWA[header['alg']]\n    encryption_key = decipher(encryption_key_ciphertext, jwk)\n\n    # decrypt body\n    ((_, decipher), _), ((hash_fn, _), mod) = JWA[header['enc']]\n\n    version = header.get(_TEMP_VER_KEY)\n    if version:\n        plaintext = decipher(ciphertext, encryption_key[-mod.digest_size/2:], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n                encryption_key[:-mod.digest_size/2], mod=mod)\n    else:\n        plaintext = decipher(ciphertext, encryption_key[:-mod.digest_size], iv)\n        hash = hash_fn(_jwe_hash_str(ciphertext, iv, adata, version),\n            encryption_key[-mod.digest_size:], mod=mod)\n\n    if not const_compare(auth_tag(hash), tag):\n        raise Error('Mismatched authentication tags')\n\n    if 'zip' in header:\n        try:\n            (_, decompress) = COMPRESSION[header['zip']]\n        except KeyError:\n            raise Error('Unsupported compression algorithm: {}'.format(\n                header['zip']))\n\n        plaintext = decompress(plaintext)\n\n    claims = json_decode(plaintext)\n    try:\n        del claims[_TEMP_VER_KEY]\n    except KeyError:\n        # expected when decrypting legacy tokens\n        pass\n\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef sign(claims, jwk, add_header=None, alg='HS256'):\n    \&quot;\&quot;\&quot; Signs the given claims and produces a :class:`~jose.JWS`\n\n    :param claims: A `dict` representing the claims for this\n                   :class:`~jose.JWS`.\n    :param jwk: A `dict` representing the JWK to be used for signing of the\n                :class:`~jose.JWS`. This parameter is algorithm-specific.\n    :parameter add_header: Additional items to be added to the header.\n                           Additional headers *will* be authenticated.\n    :parameter alg: The algorithm to use to produce the signature.\n    :rtype: :class:`~jose.JWS`\n    \&quot;\&quot;\&quot;\n    (hash_fn, _), mod = JWA[alg]\n\n    header = dict((add_header or {}).items() + [('alg', alg)])\n    header, payload = map(b64encode_url, map(json_encode, (header, claims)))\n\n    sig = b64encode_url(hash_fn(_jws_hash_str(header, payload), jwk['k'],\n        mod=mod))\n\n    return JWS(header, payload, sig)\n\n\ndef verify(jws, jwk, alg, validate_claims=True, expiry_seconds=None):\n    \&quot;\&quot;\&quot; Verifies the given :class:`~jose.JWS`\n\n    :param jws: The :class:`~jose.JWS` to be verified.\n    :param jwk: A `dict` representing the JWK to use for verification. This\n                parameter is algorithm-specific.\n    :param alg: The algorithm to verify the signature with.\n    :param validate_claims: A `bool` indicating whether or not the `exp`, `iat`\n                            and `nbf` claims should be validated. Defaults to\n                            `True`.\n    :param expiry_seconds: An `int` containing the JWT expiry in seconds, used\n                           when evaluating the `iat` claim. Defaults to `None`,\n                           which disables `iat` claim validation.\n    :rtype: :class:`~jose.JWT`\n    :raises: :class:`~jose.Expired` if the JWT has expired\n    :raises: :class:`~jose.NotYetValid` if the JWT is not yet valid\n    :raises: :class:`~jose.Error` if there is an error decrypting the JWE\n    \&quot;\&quot;\&quot;\n    header, payload, sig = map(b64decode_url, jws)\n    header = json_decode(header)\n    if alg != header['alg']:\n        raise Error('Invalid algorithm')\n\n    (_, verify_fn), mod = JWA[header['alg']]\n\n    if not verify_fn(_jws_hash_str(jws.header, jws.payload),\n            jwk['k'], sig, mod=mod):\n        raise Error('Mismatched signatures')\n\n    claims = json_decode(b64decode_url(jws.payload))\n    _validate(claims, validate_claims, expiry_seconds)\n\n    return JWT(header, claims)\n\n\ndef b64decode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    istr = encode_safe(istr)\n    try:\n        return urlsafe_b64decode(istr + '=' * (4 - (len(istr) % 4)))\n    except TypeError as e:\n        raise Error('Unable to decode base64: %s' % (e))\n\n\ndef b64encode_url(istr):\n    \&quot;\&quot;\&quot; JWT Tokens may be truncated without the usual trailing padding '='\n        symbols. Compensate by padding to the nearest 4 bytes.\n    \&quot;\&quot;\&quot;\n    return urlsafe_b64encode(encode_safe(istr)).rstrip('=')\n\n\ndef encode_safe(istr, encoding='utf8'):\n    try:\n        return istr.encode(encoding)\n    except UnicodeDecodeError:\n        # this will fail if istr is already encoded\n        pass\n    return istr\n\n\ndef auth_tag(hmac):\n    # http://tools.ietf.org/html/\n    # draft-ietf-oauth-json-web-token-19#section-4.1.4\n    return hmac[:len(hmac) // 2]\n\n\ndef pad_pkcs7(s):\n    sz = AES.block_size - (len(s) % AES.block_size)\n    return s + (chr(sz) * sz)\n\n\ndef unpad_pkcs7(s):\n    return s[:-ord(s[-1])]\n\n\ndef encrypt_oaep(plaintext, jwk):\n    return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).encrypt(plaintext)\n\n\ndef decrypt_oaep(ciphertext, jwk):\n    try:\n        return PKCS1_OAEP.new(RSA.importKey(jwk['k'])).decrypt(ciphertext)\n    except ValueError as e:\n        raise Error(e.args[0])\n\n\ndef hmac_sign(s, key, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n    return hmac.digest()\n\n\ndef hmac_verify(s, key, sig, mod=SHA256):\n    hmac = HMAC.new(key, digestmod=mod)\n    hmac.update(s)\n\n    if not const_compare(hmac.digest(), sig):\n        return False\n\n    return True\n\n\ndef rsa_sign(s, key, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).sign(hash)\n\n\ndef rsa_verify(s, key, sig, mod=SHA256):\n    key = RSA.importKey(key)\n    hash = mod.new(s)\n    return PKCS1_v1_5_SIG.new(key).verify(hash, sig)\n\n\ndef encrypt_aescbc(plaintext, key, iv):\n    plaintext = pad_pkcs7(plaintext)\n    return AES.new(key, AES.MODE_CBC, iv).encrypt(plaintext)\n\n\ndef decrypt_aescbc(ciphertext, key, iv):\n    return unpad_pkcs7(AES.new(key, AES.MODE_CBC, iv).decrypt(ciphertext))\n\n\ndef const_compare(stra, strb):\n    if len(stra) != len(strb):\n        return False\n\n    res = 0\n    for a, b in zip(stra, strb):\n        res |= ord(a) ^ ord(b)\n    return res == 0\n\n\nclass _JWA(object):\n    \&quot;\&quot;\&quot; Represents the implemented algorithms\n\n    A big TODO list can be found here:\n    http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-24\n    \&quot;\&quot;\&quot;\n    _impl = {\n        'HS256': ((hmac_sign, hmac_verify), SHA256),\n        'HS384': ((hmac_sign, hmac_verify), SHA384),\n        'HS512': ((hmac_sign, hmac_verify), SHA512),\n        'RS256': ((rsa_sign, rsa_verify), SHA256),\n        'RS384': ((rsa_sign, rsa_verify), SHA384),\n        'RS512': ((rsa_sign, rsa_verify), SHA512),\n        'RSA-OAEP': ((encrypt_oaep, decrypt_oaep), 2048),\n\n        'A128CBC': ((encrypt_aescbc, decrypt_aescbc), 128),\n        'A192CBC': ((encrypt_aescbc, decrypt_aescbc), 192),\n        'A256CBC': ((encrypt_aescbc, decrypt_aescbc), 256),\n    }\n\n    def __getitem__(self, key):\n        \&quot;\&quot;\&quot; Derive implementation(s) from key\n        \&quot;\&quot;\&quot;\n        if key in self._impl:\n            return self._impl[key]\n\n        enc, hash = self._compound_from_key(key)\n        return self._impl[enc], self._impl[hash]\n\n    def _compound_from_key(self, key):\n        try:\n            enc, hash = key.split('+')\n            return enc, hash\n        except ValueError:\n            pass\n\n        try:\n            enc, hash = key.split('-')\n            return enc, hash\n        except ValueError:\n            pass\n\n        raise Error('Unsupported algorithm: {}'.format(key))\n\n\nJWA = _JWA()\n\n\nCOMPRESSION = {\n    'DEF': (zlib.compress, zlib.decompress),\n}\n\n\ndef _format_timestamp(ts):\n    dt = datetime.datetime.utcfromtimestamp(ts)\n    return dt.isoformat() + 'Z'\n\n\ndef _check_expiration_time(now, expiration_time):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if now &gt;= expiration_time:\n        raise Expired('Token expired at {}'.format(\n            _format_timestamp(expiration_time))\n        )\n\n\ndef _check_not_before(now, not_before):\n    # Token is valid when nbf &lt;= now &lt; exp\n    if not_before &gt; now:\n        raise NotYetValid('Token not valid until {}'.format(\n            _format_timestamp(not_before))\n        )\n\n\ndef _validate(claims, validate_claims, expiry_seconds):\n    \&quot;\&quot;\&quot; Validate expiry related claims.\n\n    If validate_claims is False, do nothing.\n\n    Otherwise, validate the exp and nbf claims if they are present, and\n    validate the iat claim if expiry_seconds is provided.\n    \&quot;\&quot;\&quot;\n    if not validate_claims:\n        return\n\n    now = time()\n\n    # TODO: implement support for clock skew\n\n    # The exp (expiration time) claim identifies the expiration time on or\n    # after which the JWT MUST NOT be accepted for processing. The\n    # processing of the exp claim requires that the current date/time MUST\n    # be before the expiration date/time listed in the exp claim.\n    try:\n        expiration_time = claims[CLAIM_EXPIRATION_TIME]\n    except KeyError:\n        pass\n    else:\n        _check_expiration_time(now, expiration_time)\n\n    # The iat (issued at) claim identifies the time at which the JWT was\n    # issued. This claim can be used to determine the age of the JWT.\n    # If expiry_seconds is provided, and the iat claims is present,\n    # determine the age of the token and check if it has expired.\n    try:\n        issued_at = claims[CLAIM_ISSUED_AT]\n    except KeyError:\n        pass\n    else:\n        if expiry_seconds is not None:\n            _check_expiration_time(now, issued_at + expiry_seconds)\n\n    # The nbf (not before) claim identifies the time before which the JWT\n    # MUST NOT be accepted for processing. The processing of the nbf claim\n    # requires that the current date/time MUST be after or equal to the\n    # not-before date/time listed in the nbf claim.\n    try:\n        not_before = claims[CLAIM_NOT_BEFORE]\n    except KeyError:\n        pass\n    else:\n        _check_not_before(now, not_before)\n\n\ndef _jwe_hash_str(ciphertext, iv, adata='', version=_TEMP_VER):\n    # http://tools.ietf.org/html/\n    # draft-ietf-jose-json-web-algorithms-24#section-5.2.2.1\n    # Both tokens without version and with version 1 should be ignored in\n    # the future as they use incorrect hashing. The version parameter\n    # should also be removed.\n    if not version:\n        return '.'.join((adata, iv, ciphertext, str(len(adata))))\n    elif version == 1:\n        return '.'.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n    return ''.join((adata, iv, ciphertext, pack(\&quot;!Q\&quot;, len(adata) * 8)))\n\n\ndef _jws_hash_str(header, claims):\n    return '.'.join((header, claims))\n\n\ndef cli_decrypt(jwt, key):\n    print decrypt(deserialize_compact(jwt), {'k':key},\n        validate_claims=False)\n\n\ndef _cli():\n    import inspect\n    import sys\n\n    from argparse import ArgumentParser\n    from copy import copy\n\n    parser = ArgumentParser()\n    subparsers = parser.add_subparsers(dest='subparser_name')\n\n    commands = {\n        'decrypt': cli_decrypt,\n    }\n    for k, fn in commands.items():\n        p = subparsers.add_parser(k)\n        for arg in inspect.getargspec(fn).args:\n            p.add_argument(arg)\n\n    args = parser.parse_args()\n    handler = commands[args.subparser_name]\n    handler_args = [getattr(args, k) for k in inspect.getargspec(\n        handler).args]\n    handler(*handler_args)\n&quot;}]},&quot;createdAt&quot;:1751746607803,&quot;isInternal&quot;:false}],&quot;isAgent&quot;:false,&quot;isNameGenerated&quot;:true,&quot;isCustomAgent&quot;:false,&quot;isUnitTestsAgent&quot;:false,&quot;isE2EAgent&quot;:false,&quot;autoApply&quot;:false}}" />
  </component>
</project>